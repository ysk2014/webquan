-- phpMyAdmin SQL Dump
-- version 4.0.10deb1
-- http://www.phpmyadmin.net
--
-- 主机: localhost
-- 生成日期: 2015-11-12 11:47:38
-- 服务器版本: 5.5.44-0ubuntu0.14.04.1
-- PHP 版本: 5.5.9-1ubuntu4.13

SET SQL_MODE = "NO_AUTO_VALUE_ON_ZERO";
SET time_zone = "+00:00";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;

--
-- 数据库: `wq`
--

-- --------------------------------------------------------

--
-- 表的结构 `article`
--

CREATE TABLE IF NOT EXISTS `article` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(50) NOT NULL,
  `uid` int(11) NOT NULL,
  `cid` int(11) NOT NULL,
  `content` text NOT NULL,
  `description` text NOT NULL,
  `logo_dir` text,
  `view` int(11) DEFAULT '0',
  `tags` varchar(50) DEFAULT NULL,
  `comment` int(11) DEFAULT '0',
  `is_publish` int(1) DEFAULT '0',
  `addtime` varchar(20) NOT NULL,
  `update_time` varchar(20) NOT NULL,
  `praise` int(11) NOT NULL DEFAULT '0',
  `store` int(11) NOT NULL DEFAULT '0',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB  DEFAULT CHARSET=utf8 AUTO_INCREMENT=16 ;

--
-- 转存表中的数据 `article`
--

INSERT INTO `article` (`id`, `title`, `uid`, `cid`, `content`, `description`, `logo_dir`, `view`, `tags`, `comment`, `is_publish`, `addtime`, `update_time`, `praise`, `store`) VALUES
(2, '你为什么不分享', 7, 6, '根源\n从根源分析：你为什么会去分享？我认为你去做这个事情的主要原因有几个\n\n获得知名度\n作为知识的积累及备忘录\n扩大自己朋友圈\n想帮助他人\n而在我看来这些原因都很大程度上离不开成就感这个东西，毕竟对于绝大数人来说他的文章很难直接给他带来金钱上的直接利益。而去驱使他做没有直接实际利益的事情的时候，就必须拥有自我满足感，说的高端一点就是能够在这件事情上得到自我升华。\n\n而作为一个新人/菜鸟想去做分享这个事情的时候会遇到什么情况呢？毕竟在他们职业发展初期，很多很多场合和文章都有人告诉他们要去写自己的博客，做自己的技术积累，这样才能够迅速的提升自己。\n\n问题\n而当他们开始准备做时，提笔一挥或者说键盘一敲，一种堵在胸口的沉闷感在五分钟之内必然的遍布全身，为什么？\n\n技术是一个体系，从一个点能够引出一个面。对于新人/菜鸟很难掌控，或者说自身就没有掌握好。\n自己所理解的技术与观点很难以流畅的语言描述清楚。\n大部分的技术内容网上已经有成千上万篇文章，想有所突破。\n觉得写文章太浪费时间。\n害怕写出来的文章被人喷\n在一两个小时后，当我们呆望着屏幕上浮现的百来字，挫败感油然而生。对于上面列举的几个原因在我看来，最核心最痛苦的原因在于：对于自己所理解的技术与观点很难以流畅的语言描述清楚。在这个地方上，你会有深深的挫败感。因为你能够看得到自己的极限，却不能发挥出来。\n\n写文章分享我认为比直接面对面交流分享更难，因为你只有文字或者和图片这个途径与你的读者交流。这就要求你的文章必须通俗易懂，图片必须清晰明了，否则就会言不达意。要达到这种地步需要很深的功力和很长的训练才能够做到。\n而面对面的交流，则自由度更高一点。你能够利用你的表情/肢体/语言甚至于道具，这些都能够大大降低与交流者之间的沟通成本。\n你幻想一下，一个人打了几个字：我屁股被狗咬了。和在你面前表情夸张痛苦还顺带翘起他性感的屁股幽怨告诉你他的屁股被狗咬了。哪个影响深刻？毫无疑问是后者。那就问题引申出来了，我们需要去增强你和交流者之间的趣味和互动和降低之间的沟通成本。\n\n同样的场景不一样的描述，更加不一样的体会。你承认也好不承认也好，在这个年代人们的写作能力已经大大不如以前了。例如，你第一次看到大海(随手写的，勿喷)\n\n啊，大海，你真他妈的的大呀\n大海呀，您真的是广阔无际、波浪壮阔。\n我此前只听说过您的大名却未曾见识，此时站在您的面前我仍旧像个初生的婴儿一般脆弱，而您用温湿的风抚摸我，用您广阔的胸膛接纳我。\n同样的一个场景，我们可以看到体会到用很多不同的描述方法去陈述相同的场景所带来文字美感上的差异。我相信给相同的人看到不同的描述，也会产生理解和感悟上的巨大差异。\n\n没有很好的表达描述自己的观点和理念带来的挫败感是罪恶的源泉。毕竟你只去描述技术中某个特定的点是没有任何问题的。甚至你去写很浅显的知识由于通俗易懂会被大家认为是入门的好教程。而乱七八糟词不达意的文章，你自己都看不下去。而如何去提高自己的写作能力呢？直接说直观的结论就是多看多写。很多人就会出来说，这不是废话么？当然不是，因为这里面是有技巧的。\n\n写\n多写，是有讲究的。特别是对于技术类的文章来说，为什么？因为技术文章是有套路或者说模板可循的。例如：介绍一个新技术\n\n介绍技术名称和大概作用\n抛出一个常见的问题\n以往的技术是如何解决的\n新技术是如何解决的\n新技术在解决方案上对比旧技术的优势\n新技术存在的问题与不足\n展望新技术的发展和提出更多的应用场景\n有条件的还可以提供性能测试结果等等，加强说服力\n可以看到这个套路模板是清晰明了的，同时便于读者理解与交流的。当你按照这个规则去写的时候，文章会引导你向前。什么时候应该抛出问题，什么时候给出解决方案与结论。整个过程只要描述文字不要太过于混乱和前后矛盾，最终呈现出来的效果是令人愉悦的，而且槽点不会太多，也容易形成体系。\n这里只是列举技术文章其中一种套路，其他也大体如此就不一一列举。\n\n阅与读\n而多看，我区分狭义和广义。\n\n先谈谈狭义的多看：看（代指阅读）是为了加强对文字的阅读理解了。融会贯通后能够将技巧应用到自己文章上也是最终目的。\n这里不能不吐槽一下现在大多数人都没有沉下心来读那么一两本好书，而流于肥皂文/鸡汤文。同时作为技术人，则容易陷入只读技术书籍的泥潭。实际上我们需要跳出这个圈子去阅读一些圈子以外的内容，而这些内容会潜移默化的去改变你，或者说能够提供你在某种特定领域上的实力。\n例如：读一本书能够让你写金融相关的软件时能够更加明白为什么需要这么设计系统。简而言之，提升业务能力只会提高你的竞争力，除此之外并没什么坏处，哪怕不济也多一点聊天内容。\n而去阅读文学经典则能大大的提高你对文字的驾驭能力与阅读美感，同时还能稍微改变一下三观，毕竟我们处于一个浮躁的社会。\n\n广义的多看，是指多去了解体会你所陌生的领域，方法包括：旅游、参加会议、聊天等等一系列能够对你产生影响的行为活动。\n\n和一些涉及过财务、仓管的人聊天，我才知道，当初我做的一个仓管系统的一些功能缘由。例如：当数据不正确的时候，不能直接删除记录重新加过，只能采用对冲。因为他们需要确保每一个出入库记录都完整增加制假成本，同时方便查账。\n出去旅游一圈，我才知道，在旅游景区里的一些商家极其重视网上预订系统的评价（美团、去哪儿等）。因为大多数出去旅游的人，都会根据网上的评价和推荐去做出选择。这同时也促使了很多商家在服务上的提高。同时也是能够看出每个系统的推荐系统的功力。\n和做电商的朋友聊天，我才知道，哪怕一个商品9.9包邮也是能够有钱赚的。\n而对于一些内容你可以不精通，甚至可以不参与，可是你得知道它是什么。比如：股票里面的指数。因为你需要去和他人接触，因为你永远逃离不了金融，因为它会影响到你的生活只是你不这么认为罢了。把圈子延伸到技术圈子以外，对你的沟通交流能力、思维方式带来是不可量化的好处。\n\n通过之前的内容，只要你能够诚心、沉心去做。我相信能够大大改善阻碍在你分享学习道路上的最大阻碍：不能流畅的表达想法与思路。\n\n时之沙\n如果你去问一些博客、公众号上面的作者，他们写一篇文章大概需要多久。一般来说都是1-2小时，特别一点的文章可能会去到3-4个小时。\n这时间大概也就和你看一部电影的时间差不多。你认为这个时间多么？我认为不多，你可以统计一下你每天花在微博、微信、知乎、新闻等上面的时间，绝对超乎你的想象。\n当你熟悉怎么去写一篇文章后，会有一种了然于胸的感觉，挥墨之间一篇文章就诞生了，一气呵成。因此，觉得分享学习比较浪费时间的说法是片面的（一些优秀的技术文章可能会涉及图表的制作、流程图的绘制等等会相当相当耗时，但是不能当成普遍现象，同时也并非是分享新人/菜鸟所取涉及的）。\n因为你开始时的不熟练导致你有这么的想法，同时在把思维落入字眼间的时候，这本身就是一种自我学习与反思。\n\n技巧\n当你能够相对熟练的写出一篇技术文章后，我还有一些技巧和想法想说。\n\n晚一天发布文章！当你写完一篇文章后，你巴不得全世界都知道，都来关注，这是人性，我亦如此。但是，在短时间内你会处于亢奋状态（不知道你们有没有我是有的- -！），会让你忽略一些文章的细节。如：标点字符的选择、错别字、语句是否通顺。而让你晚一天发文章则会让有一个机会，在第二天早上以一个读者的身份去细细阅读一番你的成果，往里面挑挑刺找找茬。而经过一两遍阅读后往往能够修改上那么一两处地方。久而久之写作能力就得到提升了（之后你喜欢的话就写完直接发布），也更好的理解读者了。\n\n使用Markdown书写你的文章，原因很简单，Markdown现在已经算是广大社区平台的事实标准。你通过Markdown格式的文章能够迅速的发布到各个平台中，而不需要进行太多的更改。扩大你文章的受众面，而你只需要几个复制粘贴就可以了，不是很好么？\n\n提出更多的要求。尽量将自己处于一个读者（使用者）的视角去看待自己的作品，同时去提出一些你认为可有可无但是有能够带来体验提升的细节。对于一篇文章来说就是：这里需不需要分段、是否应该加入一个标题、是否应该加粗、字体选择、段落间的留白等等。最核心的：文章整体排版是否合理、顺眼。提升一个文章的阅读观感是我们义不容辞的责任，同时获得好评的关键点之一。\n\n从浅显/熟练的知识开始。先将你熟练了然于胸的知识做几篇练手的文章能够大大提升你的自信心。或者先从比较浅显的知识开始写起，这样你能够对比网上比较好的教程，取长补短。\n\n要熬得了寂寞。在你开始做这个事情的时候很大可能是无法取得让人瞩目的成绩与文章的，甚至一个人都没有回复你。不要介意，慢慢来，一步步来。\n\n突破\n针对网络上已经充斥着无数的类似文章，怎么去突破？我认为有几点方法：\n\n尽量完整，涵盖技术的方方面面\n文字描述尽量通俗\n配图，所谓一图胜千言\n提供可运行Demo\n其实，有类似文章重要么？我认为一点都不重要，因为第一个读者是你。而你是面向自己去做这个事情的。同时你要明白，同样一篇课文，不同语文老师，不同讲法。同一个老师，不同学生，不同领悟。不要介意，just do it！\n\n总结\n至此，我认为做到这么多已经是一个合格的分享者了（抱歉我自己也还未达到）。\n我觉得我的观点解答了之前提出阻碍你分享的原因的大部分（核心部分）了\n\n技术是一个体系，从一个点能够引出一个面。对于新人/菜鸟很难掌控，或者说自身就没有掌握好\n自己所理解的技术与观点很难以流畅的语言描述清楚\n大部分的技术内容网上已经有成千上万篇文章，想有所突破\n觉得写文章太浪费时间\n害怕写出来的文章被人喷\n此外，对于他人的劳动成果，请保持一个客观理性的态度，不要去谩骂，这是一个做人的准则。\n\n最后\n技术的深度和广度只能靠自己努力去发掘，谁也不能替你学习。而害怕被喷？开玩笑？？你信不信你写出来根本没有人看？？？起码对于我来说，被喷是一种敬意。毕竟你还在乎我想表达的内容。当然如果是因为你文章的技术槽点或错误，我建议还是虚心学习为好。我多么希望有人能够提出我所犯的错误。Talk is cheap, show me the code 互喷不爽了，去github上面来一炮吧。潇洒走一回。我支持你。\n\n\n最后的最后\n我也是一个虚荣的人，如果您不介意，不烦为我点个赞？你也不会少块肉不是么？也为我提供一些正能量去做更多更好的事情。', '这两天恰好有我的前boss在朋友圈分享他看到的文章，是关于分享的主题。作者在文章里把新人或者说菜鸟不肯分享的原因总结为害怕被所谓的高手/大牛所打脸而害怕分享。从我的经历来说，我认为这并非核心原因，仅仅是次要原因之一。因此特意写此文与大家探讨一下。', '', 45, '', 4, 1, '1444442363', '1446020358', 0, 2),
(3, '个人首页接口', 5, 7, '\n### 1. 获取个人信息\n方法：\n\n	UserModel.getUserInfoById(data,callback)\n\n参数\n\n    {\n		id:id   //用户id\n	}  \n返回数据\n\n\n    {\n    	error: true|false,\n    	data: {},             //用户信息数据\n    	msg: '''',              //返回的字符串信息\n    }\n\n### 2.获取文章列表\n方法：\n\n    ArticleModel.getAllArticleByUid(data,callback)\n\n参数：\n\n\n    {\n    	uid: 用户id，\n    	way: 排序方式，view：最热排序，addtime：最新排序，\n    	page: 分页，从0开始\n    	is_publish: 文章公布状态，0：草稿箱，未公布；1：已公布的(默认)\n    }\n\n返回数据\n\n\n        {\n        	error: true|false,\n        	data: {},             //文章列表\n    		next: true|false,   //是否含有下一页数据\n        	msg: '''',              //error为true的情况下，返回的字符串信息\n        }\n    \n文章列表模板\n```javascript\nvar list = (this.state.list[nav] && this.state.list[nav].length>0) ? this.state.list[nav].map(function(d,i) {\n\n				if(d.tags) {\n					if(d.tags.indexOf(''|'')) {\n						var tagsList = d.tags.split(''|'').map(function(t,k) {\n							return (<a style={{marginRight:''6px''}} href={"/t/"+t}>{t}</a>);\n						});\n					} else {\n						var tagsList = (<a href={"/t/"+d.tags}>d.tags</a>);\n					}\n					tagsList = (<span className="tag">&nbsp;<i className="fa fa-tags"></i>&nbsp;{tagsList}</span>);\n				} else {\n					var tagsList = null;\n				}\n				return (\n					<article key={d.id}>\n						{\n							d.logo_dir ? \n							(<a className="pic" href={"/article/"+d.id} style={{backgroundImage: ''url(''+d.logo_dir+'')''}}>\n								<span>{d.cloumn}</span>\n							</a>) : null\n						}\n						\n						<div className="desc">\n							<a className="title" href={"/article/"+d.id}>{d.title}</a>\n							<div className="author">\n								<a href="javascript:void(0)">\n									<img className="avatar" src={d.userUrl ? d.userUrl : "/image/user-default.png"} />\n									<span className="name">{d.username}</span>\n								</a>\n								<span className="time">&nbsp;•&nbsp;{WQ.timeFormat(d.addtime)}</span>\n								<span className="tag">&nbsp;阅读:&nbsp;{d.view}</span>\n								<span className="tag">&nbsp;推荐:&nbsp;{d.praise}</span>\n								<span className="tag">&nbsp;评论:&nbsp;{d.comment}</span>\n								{tagsList}\n							</div>\n							<div className="description">{d.description}</div>\n						</div>\n					</article>\n				);\n			}) : null;\n```\n其中，this.state.list存放按way方式排序的文章列表', '个人首页的接口，参数类型及其个数', '', 31, 'php', 0, 1, '1444540960', '', 0, 0),
(4, '文章API改版', 5, 7, '|  文章页面 |  GET | /article/:id  |\n| ------------ | ------------ | ------------ |\n| 获取一片文章  |  GET |  /article/:id/info |\n| 添加一片文章  | POST  |  /article/add |\n|  删除一片文章 |  DELETE |  /article/:id  |\n| 更新一片文章  | PUT  |  /article/:id  |\n| 文章编辑页面  | GET  | /article/add  |\n| 文章编辑页面  | GET  |  /article/:id/edit |\n|  已公布的文章列表 | GET  |  /articles |\n|  某个专题下的文章列表 | GET  | /articles/cloumn/:cid  |\n|  用户关注专题的文章列表 |  GET |  /articles/care/cloumns |\n|  用户的文章列表 |  GET | /articles/user/:uid  |\n|  单个标签的文章列表 | GET  | /articles/tag/:name  |\n| 推荐一片文章  |  POST |  /article/:id/praise |\n| 取消推荐  | DELETE  | /article/:id/praise  |\n| 收藏一片文章  |  POST | /article/:id/store  |\n|  取消收藏 | DELETE  | /article/:id/store  |\n| 一片文章的评论列表  |  GET |  /article/:id/comments |\n| 添加评论  | POST  | /article/:id/comment  |\n| 删除评论  | DELETE  | /article/:id/comment  |\n\n文章表字段\n\n    {\n    	addtime: "1444618010"\n    	update_time: "1444618010"\n    	cid: 5\n    	cloumnName: "测试logo"\n    	comment: 0\n    	content: "测试文章添加路由"\n    	description: "测试文章添加路由"\n    	id: 3\n    	is_publish: 1\n    	logo_dir: ""\n    	praise: 3\n    	praiseStatus: true\n    	store: 6\n    	storeStatus: true\n    	tags: ""\n    	title: "测试文章添加路由"\n    	uid: 5\n    	username: "殷士凯"\n    	view: 31\n    }\n\n| 字段  | 意义  | 备注  |\n| ------------ | ------------ | ------------ |\n| addtime  | 发布时间  | 无  |\n| update_time   | 更新时间  |  最后一次编辑的时间 |\n| cid  | 专题id  | 无  |\n| comment   | 评论数  |  无 |\n| content   | 文章内容  |  无 |\n|  description  | 文章简介  | 无  |\n|  id | 文章id  | 无  |\n| is_publish   | 是否公布  | 公布为1，保存到草稿为0  |\n| logo_dir   | 文章logo  | 程序自动获取文章内容中第一张图片为文章logo，没有则为空  |\n|  praise  | 推荐数  | 无  |\n| store   |  收藏数 |  无 |\n| tags  | 文章标签组  | 字符串类型，两个标签之间用竖线隔开  |\n|  title  | 文章标题  | 无  |\n| uid  | 作者id  |  无 |\n| view  | 浏览量  | 无  |\n\n### 添加一片文章\n    POST     /article/add\n\n请求参数\n\n| 名称  | 含义  | 备注  |\n| ------------ | ------------ | ------------ |\n| titile  | 文章标题  | 必传  |\n|  uid | 作者id  |  必传 |\n| cid  |  专题id |  必传 |\n| content  | 文章内容  |  必传 |\n| description  | 文章简介  | 必传  |\n| tags  | 标签  | 选传  |\n\n返回数据：\n\n    {\n    	error: true|false,      //添加成功返回false，失败返回true\n    	data: id,                   //error为false时，返回的数据，为创建的文章id\n    	msg: ''添加失败''       //error为true时，返回的数据，为失败信息\n    }\n\n### 删除一片文章\n    DELETE   /article/:id\n\n返回数据：\n\n        {\n        	error: true|false,      //成功返回false，失败返回true\n        	msg: ''删除成功|失败''       /返回的数据信息\n        }\n\n### 更新一片文章\n    PUT     /article/:id\n\n请求参数\n\n| 参数  | 含义  | 备注  |\n| ------------ | ------------ | ------------ |\n| titile  | 文章标题  | 必传  |\n|  uid | 作者id  |  必传 |\n| cid  |  专题id |  必传 |\n| content  | 文章内容  |  必传 |\n| description  | 文章简介  | 必传  |\n| tags  | 标签  | 选传  |\n\n返回数据：\n\n    {\n    	error: true|false,      //成功返回false，失败返回true\n    	msg: ''更新成功|失败''       //返回的数据信息\n    }\n\n### 文章列表\n    GET      /articles                            //已公布的文章列表\n	GET      /articles/cloumn/:cid       //某个专题下的文章列表\n	GET      /articles/care/cloumns   //用户关注专题的文章列表\n	GET      /articles/user/:uid           //用户的文章列表\n	GET      /articles/tag/:name        //单个标签的文章列表\n\n通用的请求参数\n\n| 参数  | 含义  | 备注  |\n| ------------ | ------------ | ------------ |\n| way  | 排序方式  | praise(推荐)、addtime(最新)、view(最热)  |\n|  page | 页数  |  从0开始 |\n\n通用的返回数据：\n\n    {\n    	error: true|false,\n    	data: [],                  //文章列表数组\n    	next: true|false,    //是否含有下一页数据\n    	msg: ''''                   //请求失败，返回失败信息\n    }\n\n#### 某个专题下的文章列表\n    GET      /articles/cloumn/:cid       //某个专题下的文章列表\n\n特殊请求参数\n\n| 参数  | 含义  | 备注  |\n| ------------ | ------------ | ------------ |\n| cid  | 专题id  | 无  |\n\n#### 用户关注专题的文章列表\n    GET     /articles/care/cloumns       //用户关注专题的文章列表\n\n特殊请求参数\n\n| 参数  | 含义  | 备注  |\n| ------------ | ------------ | ------------ |\n| uid  | 用户id  | 无  |\n\n#### 用户的文章列表\n    GET     /articles/user/:uid       //用户的文章列表\n\n特殊请求参数\n\n| 参数  | 含义  | 备注  |\n| ------------ | ------------ | ------------ |\n| uid  | 用户id  | 无  |\n\n#### 单个标签的文章列表\n    GET    /articles/tag/:name       //单个标签的文章列表\n\n特殊请求参数\n\n| 参数  | 含义  | 备注  |\n| ------------ | ------------ | ------------ |\n| name  | 标签名称  | 无  |\n\n### 推荐和收藏一片文章\n    POST        /article/:id/praise     //推荐一片文章\n	POST        /article/:id/store       //收藏一片文章\n\n请求参数\n\n| 参数  | 含义  | 备注  |\n| ------------ | ------------ | ------------ |\n| aid  | 文章id  | 无  |\n| type  | 类型  | 0为推荐，1为收藏  |\n\n返回的数据\n\n    {\n    	error: true|false,\n    	msg: ''''                   //请求成功或者失败，返回的信息\n    }\n\n### 取消推荐和收藏\n    DELETE     /article/:id/praise\n	DELETE    /article/:id/store\n\n请求参数\n\n| 参数  | 含义  | 备注  |\n| ------------ | ------------ | ------------ |\n| aid  | 文章id  | 无  |\n\n### 一片文章的评论列表\n    GET      /article/:id/comments   //一片文章的评论列表\n\n请求参数\n\n| 参数  | 含义  | 备注  |\n| ------------ | ------------ | ------------ |\n| aid  | 文章id  | 无  |\n|  page | 页数  |  从0开始 |\n\n通用的返回数据：\n\n    {\n    	error: true|false,\n    	data: [],                  //评论列表数组\n    	next: true|false,    //是否含有下一页数据\n    	msg: ''''                   //请求失败，返回失败信息\n    }\n\n### 添加评论\n		POST        /article/:id/comment     //添加评论\n\n请求参数\n\n| 参数  | 含义  | 备注  |\n| ------------ | ------------ | ------------ |\n| aid  | 文章id  | 无  |\n| content  | 评论内容  | 无  |\n| uid  | 用户id  | 无  |\n\n返回的数据\n\n    {\n    	error: true|false,\n		data: {\n			id: 1,   //评论id\n			addtime: 13232328990,    //添加评论的时间\n		},\n    	msg: ''''                   //请求成功或者失败，返回的信息\n    }\n\n### 删除评论\n    DELETE     /article/:id/comment\n\n请求参数\n\n| 参数  | 含义  | 备注  |\n| ------------ | ------------ | ------------ |\n| cid  | 评论id  | 无  |', '描述文章各个接口，及其所需传的参数和返回的json数据', '', 21, 'php', 0, 1, '1444630417', '', 0, 0),
(5, '专题API接口改版文档', 5, 7, '| 专题页面  | GET  | /cloumn/:id  |\n| ------------ | ------------ | ------------ |\n| 专题列表页  | GET  | /cloumns  |\n| 编辑专题页  | GET  | /cloumn/:id/edit  |\n| 添加专题页  | GET  |  /cloumn/add |\n| 获取单个专题数据信息  | GET  | /cloumn/:id/info  |\n|  创建专题 | POST  | /cloumn/add  |\n| 更新专题  | PUT  | /cloumn/:id  |\n| 删除专题  | DELETE  | /cloumn/:id  |\n| 获取专题列表  | GET  | /cloumns/info  |\n|  获取用户创建的专题 | GET  | /cloumns/user/:uid  |\n| 获取用户关注的专题  | GET  | /cloumns/care/user/:uid  |\n|  添加关注 | POST  | /cloumn/:id/care  |\n|  取消关注 | DELETE  | /cloumn/:id/care  |\n| 上传专题logo  | POST  | /cloumn/logo  |\n', '专题API接口改版文档', '', 18, 'php', 0, 1, '1444704996', '1444711080', 0, 0),
(6, '多维数组操作', 5, 8, '**数组中的元素能够以字母或数字顺序进行升序或降序排序**。\n### PHP - 数组的一维排序函数\n- sort() - 以升序对数组排序\n- rsort() - 以降序对数组排序\n- asort() - 根据值，以升序对关联数组进行排序\n- ksort() - 根据键，以升序对关联数组进行排序\n- arsort() - 根据值，以降序对关联数组进行排序\n- krsort() - 根据键，以降序对关联数组进行排序\n\n#### 1. 对数组进行升序排序 - sort()\n下面的例子按照字母升序对数组 $cars 中的元素进行排序：\n```php\n<?php\n$cars=array("Volvo","BMW","SAAB");\nsort($cars);\n?>\n```\n运行结果：\n\n    BMW，SAAB，Volvo\n\n下面的例子按照数字升序对数组 $numbers 中的元素进行排序：\n```php\n<?php\n$numbers=array(3,5,1,22,11);\nsort($numbers);\n?>\n```\n运行结果：\n\n    1，3，5，11， 22\n\n#### 2.对数组进行降序排序 - rsort()\n下面的例子按照字母降序对数组 $cars 中的元素进行排序：\n```php\n<?php\n$cars=array("Volvo","BMW","SAAB");\nrsort($cars);\n?>\n```\n运行结果：\n\n    Volvo，SAAB，BMW\n\n下面的例子按照数字降序对数组 $numbers 中的元素进行排序：\n```php\n<?php\n$numbers=array(3,5,1,22,11);\nrsort($numbers);\n?>\n```\n运行结果：\n\n    22，11，5，3，1\n\n#### 3.根据值对数组进行升序排序 - asort()\n下面的例子根据值对关联数组进行升序排序：\n```php\n<?php\n$age=array("Bill"=>"35","Steve"=>"37","Peter"=>"43");\nasort($age);\n?>\n```\n运行结果：\n\n    Key=Bill, Value=35\n    Key=Steve, Value=37\n    Key=Peter, Value=43\n\n#### 4.根据键对数组进行升序排序 - ksort()\n下面的例子根据键对关联数组进行升序排序：\n```php\n<?php\n$age=array("Bill"=>"35","Steve"=>"37","Peter"=>"43");\nksort($age);\n?>\n```\n运行结果：\n\n    Key=Bill, Value=35\n    Key=Peter, Value=43\n    Key=Steve, Value=37\n\n#### 5.根据值对数组进行降序排序 - arsort()\n下面的例子根据值对关联数组进行降序排序：\n```php\n<?php\n$age=array("Bill"=>"35","Steve"=>"37","Peter"=>"43");\narsort($age);\n?>\n```\n运行结果：\n\n    Key=Peter, Value=43\n    Key=Steve, Value=37\n    Key=Bill, Value=35\n\n#### 6.根据键对数组进行降序排序 - krsort()\n下面的例子根据键对关联数组进行降序排序：\n```php\n<?php\n$age=array("Bill"=>"35","Steve"=>"37","Peter"=>"43");\nkrsort($age);\n?>\n```\n运行结果：\n\n    Key=Steve, Value=37\n    Key=Peter, Value=43\n    Key=Bill, Value=35\n\n### PHP - 数组的二维排序函数\n- uasort() - 使用用户自定义的比较函数对数组中的值进行排序并保持索引关联。\n- uksort() - 使用用户自定义的比较函数对数组中的键名进行排序。\n\n#### 1. 使用用户自定义的比较函数对数组中的值进行排序 - uasort()\n**定义和用法**\n- uasort() 函数使用用户自定义的比较函数对数组排序，并保持索引关联（不为元素分配新的键）。\n- 如果成功则返回 TRUE，否则返回 FALSE。\n- 该函数主要用于对那些单元顺序很重要的结合数组进行排序。\n\n**语法**\n\n    uasort(array,sorttype)\n\n| 参数  |  描述 |\n| ------------ | ------------ |\n|  array | 必需。规定要排序的数组。  |\n| function  | 必需。用户自定义的函数。函数必须设计为返回 -1, 0, 或 1，并应该接受两个供比较的参数，同时以类似下面这样的方式来工作：如果 a = b, 返回 0；如果 a < b, 返回 1；如果 a > b, 返回 -1  |\n**例子**\n```php\n<?php\nfunction my_sort($a, $b) {\n	  if ($a == $b) return 0;\n	  return ($a > $b) ? -1 : 1;\n  }\n\n$people = array("Swanson" => "Joe", \n"Griffin" => "Peter", "Quagmire" => "Glenn",\n"swanson" => "joe", "griffin" => "peter",\n"quagmire" => "glenn"); \n\nuasort($people, "my_sort");\n\nprint_r ($people);\n?>\n```\n输出：\n```php\nArray (\n	[griffin] => peter\n	[swanson] => joe\n	[quagmire] => glenn\n	[Griffin] => Peter\n	[Swanson] => Joe\n	[Quagmire] => Glenn\n)\n```\n#### 2.使用用户自定义的比较函数按照键名对数组排序 - uksort()\n**定义和用法**\n- uksort() 函数使用用户自定义的比较函数按照键名对数组排序，并保持索引关系。\n- 如果成功则返回 TRUE，否则返回 FALSE。\n- 如果要排序的数组需要用一种不寻常的标准进行排序，那么应该使用此函数。\n- 自定义函数应接受两个参数，该参数将被数组中的一对键名填充。比较函数在第一个参数小于，等于，或大于第二个参数时必须分别返回一个小于零，等于零，或大于零的整数。\n\n**语法**\n\n    uksort(array,sorttype)\n\n|  参数 |  描述 |\n| ------------ | ------------ |\n| array  | 必需。规定要排序的数组。  |\n|  function | 必需。用户自定义的函数。函数必须设计为返回 -1, 0, 或 1，并应该接受两个供比较的参数，同时以类似下面这样的方式来工作：如果 a = b, 返回 0；如果 a > b, 返回 1；如果 a < b, 返回 -1  |\n**例子**\n```php\n<?php\nfunction my_sort($a, $b) {\n	  if ($a == $b) return 0;\n	  return ($a > $b) ? -1 : 1;\n  }\n\n$people = array("Swanson" => "Joe", \n"Griffin" => "Peter", "Quagmire" => "Glenn",\n"swanson" => "joe", "griffin" => "peter",\n"quagmire" => "glenn"); \n\nuksort($people, "my_sort");\n\nprint_r ($people);\n?>\n```\n输出：\n```php\nArray (\n	[swanson] => joe\n	[quagmire] => glenn\n	[griffin] => peter\n	[Swanson] => Joe\n	[Quagmire] => Glenn\n	[Griffin] => Peter\n)\n```\n', '主要讲述了PHP的sort、ksort、asort、usort、uasort、uksort等方法的使用', '', 25, 'php', 0, 1, '1445220918', '1445223281', 0, 1),
(7, 'PHP的静态变量和静态属性', 5, 8, '### 静态变量\n静态变量只存在于函数作用域内，也就是说，静态变量只存活在栈中。一般的函数内变量在函数结束后会释放，比如局部变量，但是静态变量却不会。就是说，下次再调用这个函数的时候，该变量的值会保留下来。\n只要在变量前加上关键字static，该变量就成为静态变量了。\n```php\n<?php\n	function test()\n	{\n		static $nm = 1;\n		$nm = $nm * 2;\n		print $nm."<br />";\n	}\n	\n    // 第一次执行，$nm = 2\n	test();\n    // 第一次执行，$nm = 4\n	test();\n    // 第一次执行，$nm = 8\n	test();\n?>\n```\n程序运行结果：\n```php\n2\n4\n8\n```\n函数test()执行后，变量$nm的值都保存了下来了。\n在class中经常使用到静态属性，比如静态成员、静态方法。\n### 类的静态成员\n静态变量$nm属于类nowamagic，而不属于类的某个实例。这个变量对所有实例都有效。\n::是作用域限定操作符，这里用的是self作用域，而不是$this作用域，$this作用域只表示类的当前实例，self::表示的是类本身。\n```php\n<?php\n	class nowamagic \n	{\n		public static $nm = 1;\n		\n		function nmMethod() \n		{\n			self::$nm += 2;\n			echo self::$nm . ''<br />'';\n		}\n	}\n	\n	$nmInstance1 = new nowamagic();\n	$nmInstance1 -> nmMethod();\n	\n	$nmInstance2 = new nowamagic();\n	$nmInstance2 -> nmMethod();\n?> \n```\n程序运行结果：\n```php\n3\n5\n```\n#### 1. 静态属性\n```php\n    \n<?php\n	class NowaMagic\n	{\n    	public static $nm = ''www.nowamagic.net'';\n\n    	public function nmMethod() \n		{\n        	return self::$nm;\n    	}\n	}\n	\n	class Article extends NowaMagic\n	{\n    	public function articleMethod() \n		{\n        	return parent::$nm;\n    	}\n	}\n	\n	// 通过作用于限定操作符访问静态变量\n	print NowaMagic::$nm . "<br />";\n	\n	// 调用类的方法\n	$nowamagic = new NowaMagic();\n	print $nowamagic->nmMethod() . "<br />";\n	\n	print Article::$nm . "<br />";\n	\n	$nmArticle = new Article();\n	print $nmArticle->nmMethod() . "<br />";\n?>\n```\n程序运行结果：\n```php\nwww.nowamagic.net\nwww.nowamagic.net\nwww.nowamagic.net\nwww.nowamagic.net\n```\n#### 2.简单的静态构造器\nPHP没有静态构造器，你可能需要初始化静态类，有一个很简单的方法，在类定义后面直接调用类的Demonstration()方法。\n```php\n<?php\nfunction Demonstration()\n{\n    return ''This is the result of demonstration()'';\n}\n\nclass MyStaticClass\n{\n    //public static $MyStaticVar = Demonstration(); //!!! FAILS: syntax error\n    public static $MyStaticVar = null;\n\n    public static function MyStaticInit()\n    {\n        //this is the static constructor\n        //because in a function, everything is allowed, including initializing using other functions\n        \n        self::$MyStaticVar = Demonstration();\n    }\n} MyStaticClass::MyStaticInit(); //Call the static constructor\n\necho MyStaticClass::$MyStaticVar;\n//This is the result of demonstration()\n?>\n```\n程序运行结果：\n```php\nThis is the result of demonstration()\n```\n\n[原文链接](http://www.nowamagic.net/php/php_StaticVariable.php "原文链接")', '静态变量只存在于函数作用域内，也就是说，静态变量只存活在栈中。一般的函数内变量在函数结束后会释放，比如局部变量，但是静态变量却不会。就是说，下次再调用这个函数的时候，该变量的值会保留下来。', '', 23, 'php', 1, 1, '1445393743', '1445393797', 1, 1),
(8, 'laravel5.0 之事件及处理程序解析', 5, 8, '今天研究了一下laravel事件处理。看了官方文档后，脑袋都大了（自我认为官方文档说的不是太详细，又没有列子参考），自己搜索了一下教程，在参考laravel5_backend这个项目中的代码，终于明白了laravel事件机制的使用。\n提示：如果你还没有看过 [官方文档](http://www.golaravel.com/laravel/docs/5.0/events/ "官方文档")，建议先看一下。它包括了本文所需的背景知识。\n在这里事件系统的作用就不说了，其他地方都说的很明白。下面我就直接以例子来做说明：\n#### 示例\n写个添加用户操作日志绑定事件\n#### 生成事件\n```php\n$ php artisan make:event ActionLog\n```\n... 这行命令会生成下面的代码：\n```php\n<?php\n\nnamespace App\\Events;\n\nuse App\\Events\\Event;\nuse Illuminate\\Queue\\SerializesModels;\nuse Illuminate\\Contracts\\Broadcasting\\ShouldBroadcast;\n\nclass ActionLog extends Event\n{\n    use SerializesModels;\n\n    /**\n     * Create a new event instance.\n     *\n     * @return void\n     */\n    public function __construct()\n    {\n        //\n    }\n\n    /**\n     * Get the channels the event should be broadcast on.\n     *\n     * @return array\n     */\n    public function broadcastOn()\n    {\n        return [];\n    }\n}\n\n```\n你可以给构造函数添加参数并把参数值绑定到类的属性值，通过这样的方式为这个类提供额外的数据。\n```php\n<?php\nnamespace App\\Events;\n\nuse App\\Events\\Event;\nuse Illuminate\\Queue\\SerializesModels;\nuse Illuminate\\Contracts\\Broadcasting\\ShouldBroadcast;\n\nclass ActionLog extends Event\n{\n    use SerializesModels;\n\n	public $message;\n\n    /**\n     * Create a new event instance.\n     *\n     * @return void\n     */\n    public function __construct($message)\n    {\n        $this->message = $message;\n    }\n\n    /**\n     * Get the channels the event should be broadcast on.\n     *\n     * @return array\n     */\n    public function broadcastOn()\n    {\n        return [];\n    }\n}\n```\n#### 生成事件处理程序\n执行命令：\n```php\n$ php artisan handler:event ActionLog --event="ActionLog"\n```\n在`App\\Handlers\\Events`里生成`ActionLog.php`文件。这行代码会生成下面的代码：\n```php\n<?php\n\nnamespace App\\Handlers\\Events;\n\nuse App\\Events\\ThingWasDone;\nuse Illuminate\\Queue\\InteractsWithQueue;\nuse Illuminate\\Contracts\\Queue\\ShouldQueue;\n\nuse App\\Models\\Admin\\ActionLog as ActionLogModel;\n\nclass ActionLog\n{\n    /**\n     * Create the event handler.\n     *\n     * @return void\n     */\n    public function __construct()\n    {\n        $this->model = new ActionLogModel();\n    }\n\n    /**\n     * Handle the event.\n     *\n     * @param  ThingWasDone  $event\n     * @return void\n     */\n    public function handle(ActionLog $event)\n    {\n        $this->model->add($event->message);\n    }\n}\n\n```\n需要注意的一点是，生成的代码中，已经为 handle 方法指定了一个带有类型约束的 ActionLog $event 参数。不管是构造函数还是 event 方法，你都可以借助依赖注入来提供任何你需要的工具或对象。\n#### 绑定事件\n在上一个步骤中我们创建了一个事件及其处理程序，但仅仅是创建，并没有通知事件总线（bus）我们刚才创建的事件和处理程序是配对的。所以接下来还需要在 app\\Providers\\EventServiceProvider 中绑定它们的监听关系，可以在 $listen 属性中做这件事：\n```php\n    protected $listen = [\n        ''App\\Events\\ActionLog'' => [\n            ''App\\Handlers\\ActionLog'',\n        ],\n    ];\n```\n#### “预备...瞄准...开火(::fire)”\n好了，一切准备就绪，接下来就是触发该事件了。要注意的是这里只有简单的 PHP 类，所以你可以手动实例化事件，实例化事件对应的处理程序，然后把事件传递给处理程序。但那当然不是 Laravel 的思路， Laravel 提供了事件总线让以上这一系列的工作更简单，更具有一致性和全局性：\n```php\n\\Event::fire(new ActionLog($param1));\n```\n或者：\n```php\nevent(new ActionLog($param1));\n```\n这句代码可以写到你的controller里面，或者是controller指向的处理程序里面，注意命名空间的使用，在执行上面代码的程序中，添加如下代码：\n```php\nuse App\\Events\\ActionLog;\n```\n就这么简单！\n#### 写在最后\n就这么多了。只要你理解了 Laravel 5 的命令和处理程序，掌握事件处理机制就是一件非常容易的事了。触发系统向整个应用发出 通知 说某个事件发生了，而不是 要求 系统执行某些操作。但本质上它们都是封装的信息和目的。它们可以互相配合使用，结果会更棒！', '今天研究了一下laravel事件处理。看了官方文档后，脑袋都大了（自我认为官方文档说的不是太详细，又没有列子参考），自己搜索了一下教程，在参考laravel5_backend这个项目中的代码，终于明白了laravel事件机制的使用。', NULL, 10, 'php', 0, 1, '1445416350', '1445416350', 0, 1);
INSERT INTO `article` (`id`, `title`, `uid`, `cid`, `content`, `description`, `logo_dir`, `view`, `tags`, `comment`, `is_publish`, `addtime`, `update_time`, `praise`, `store`) VALUES
(9, 'Redis内存使用优化与存储', 5, 9, '### Redis常用数据类型\nRedis最为常用的数据类型主要有以下五种：\n- String\n- Hash\n- List\n- Set\n- Sorted set\n\n在具体描述这几种数据类型之前，我们先通过一张图了解下Redis内部内存管理中是如何描述这些不同数据类型的：\n![](/upload_path/20151024/14456981905.jpg)\n\n首先Redis内部使用一个redisObject对象来表示所有的key和value,redisObject最主要的信息如上图所示：type代表一个value对象具体是何种数据类型，encoding是不同数据类型在redis内部的存储方式，比如：type=string代表value存储的是一个普通字符串，那么对应的encoding可以是raw或者是int,如果是int则代表实际redis内部是按数值型类存储和表示这个字符串的，当然前提是这个字符串本身可以用数值表示，比如:"123" "456"这样的字符串。\n\n这里需要特殊说明一下vm字段，只有打开了Redis的虚拟内存功能，此字段才会真正的分配内存，该功能默认是关闭状态的，该功能会在后面具体描述。通过上图我们可以发现Redis使用redisObject来表示所有的key/value数据是比较浪费内存的，当然这些内存管理成本的付出主要也是为了给Redis不同数据类型提供一个统一的管理接口，实际作者也提供了多种方法帮助我们尽量节省内存使用，我们随后会具体讨论。\n下面我们先来逐一的分析下这五种数据类型的使用和内部实现方式：\n\n**String**\n\n常用命令：\nset,get,decr,incr,mget 等。\n\n应用场景：\nString是最常用的一种数据类型，普通的key/value存储都可以归为此类，这里就不所做解释了。\n\n实现方式：\nString在redis内部存储默认就是一个字符串，被redisObject所引用，当遇到incr,decr等操作时会转成数值型进行计算，此时redisObject的encoding字段为int。\n\n**Hash**\n\n常用命令：\nhget,hset,hgetall 等。\n\n应用场景：\n我们简单举个实例来描述下Hash的应用场景，比如我们要存储一个用户信息对象数据，包含以下信息：\n\n用户ID为查找的key，存储的value用户对象包含姓名，年龄，生日等信息，如果用普通的key/value结构来存储，主要有以下2种存储方式：\n![](/upload_path/20151024/14456982448.jpg)\n\n第一种方式将用户ID作为查找key,把其他信息封装成一个对象以序列化的方式存储，这种方式的缺点是，增加了序列化/反序列化的开销，并且在需要修改其中一项信息时，需要把整个对象取回，并且修改操作需要对并发进行保护，引入CAS等复杂问题。\n![](/upload_path/20151024/14456983259.jpg)\n\n第二种方法是这个用户信息对象有多少成员就存成多少个key-value对儿，用用户ID+对应属性的名称作为唯一标识来取得对应属性的值，虽然省去了序列化开销和并发问题，但是用户ID为重复存储，如果存在大量这样的数据，内存浪费还是非常可观的。\n\n那么Redis提供的Hash很好的解决了这个问题，Redis的Hash实际是内部存储的Value为一个HashMap，并提供了直接存取这个Map成员的接口，如下图：\n![](/upload_path/20151024/14456983657.jpg)\n\n也就是说，Key仍然是用户ID, value是一个Map，这个Map的key是成员的属性名，value是属性值，这样对数据的修改和存取都可以直接通过其内部Map的Key(Redis里称内部Map的key为field), 也就是通过 key(用户ID) + field(属性标签) 就可以操作对应属性数据了，既不需要重复存储数据，也不会带来序列化和并发修改控制的问题。很好的解决了问题。\n\n这里同时需要注意，Redis提供了接口(hgetall)可以直接取到全部的属性数据,但是如果内部Map的成员很多，那么涉及到遍历整个内部Map的操作，由于Redis单线程模型的缘故，这个遍历操作可能会比较耗时，而另其它客户端的请求完全不响应，这点需要格外注意。\n\n实现方式：\n\n上面已经说到Redis Hash对应Value内部实际就是一个HashMap，实际这里会有2种不同实现，这个Hash的成员比较少时Redis为了节省内存会采用类似一维数组的方式来紧凑存储，而不会采用真正的HashMap结构，对应的value redisObject的encoding为zipmap,当成员数量增大时会自动转成真正的HashMap,此时encoding为ht。\n\n**List**\n\n常用命令：\nlpush,rpush,lpop,rpop,lrange等。\n\n应用场景：\nRedis list的应用场景非常多，也是Redis最重要的数据结构之一，比如twitter的关注列表，粉丝列表等都可以用Redis的list结构来实现，比较好理解，这里不再重复。\n\n实现方式：\nRedis list的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销，Redis内部的很多实现，包括发送缓冲队列等也都是用的这个数据结构。\n\n**Set**\n\n常用命令：\nsadd,spop,smembers,sunion 等。\n\n应用场景：\nRedis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。\n\n实现方式：\nset 的内部实现是一个 value永远为null的HashMap，实际就是通过计算hash的方式来快速排重的，这也是set能提供判断一个成员是否在集合内的原因。\n\n**Sorted set**\n\n常用命令：\nzadd,zrange,zrem,zcard等\n\n使用场景：\nRedis sorted set的使用场景与set类似，区别是set不是自动有序的，而sorted set可以通过用户额外提供一个优先级(score)的参数来为成员排序，并且是插入有序的，即自动排序。当你需要一个有序的并且不重复的集合列表，那么可以选择sorted set数据结构，比如twitter 的public timeline可以以发表时间作为score来存储，这样获取时就是自动按时间排好序的。\n\n实现方式：\nRedis sorted set的内部使用HashMap和跳跃表(SkipList)来保证数据的存储和有序，HashMap里放的是成员到score的映射，而跳跃表里存放的是所有的成员，排序依据是HashMap里存的score,使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单。\n\n### 常用内存优化手段与参数\n\n通过我们上面的一些实现上的分析可以看出redis实际上的内存管理成本非常高，即占用了过多的内存，作者对这点也非常清楚，所以提供了一系列的参数和手段来控制和节省内存，我们分别来讨论下。\n\n首先最重要的一点是不要开启Redis的VM选项，即虚拟内存功能，这个本来是作为Redis存储超出物理内存数据的一种数据在内存与磁盘换入换出的一个持久化策略，但是其内存管理成本也非常的高，并且我们后续会分析此种持久化策略并不成熟，所以要关闭VM功能，请检查你的redis.conf文件中 vm-enabled 为 no。\n\n其次最好设置下redis.conf中的maxmemory选项，该选项是告诉Redis当使用了多少物理内存后就开始拒绝后续的写入请求，该参数能很好的保护好你的Redis不会因为使用了过多的物理内存而导致swap,最终严重影响性能甚至崩溃。\n\n另外Redis为不同数据类型分别提供了一组参数来控制内存使用，我们在前面详细分析过Redis Hash是value内部为一个HashMap，如果该Map的成员数比较少，则会采用类似一维线性的紧凑格式来存储该Map, 即省去了大量指针的内存开销，这个参数控制对应在redis.conf配置文件中下面2项：\n\nhash-max-zipmap-entries 64 \nhash-max-zipmap-value 512 \nhash-max-zipmap-entries\n含义是当value这个Map内部不超过多少个成员时会采用线性紧凑格式存储，默认是64,即value内部有64个以下的成员就是使用线性紧凑存储，超过该值自动转成真正的HashMap。\n\nhash-max-zipmap-value 含义是当 value这个Map内部的每个成员值长度不超过多少字节就会采用线性紧凑存储来节省空间。\n\n以上2个条件任意一个条件超过设置值都会转换成真正的HashMap，也就不会再节省内存了，那么这个值是不是设置的越大越好呢，答案当然是否定的，HashMap的优势就是查找和操作的时间复杂度都是O(1)的，而放弃Hash采用一维存储则是O(n)的时间复杂度，如果\n\n成员数量很少，则影响不大，否则会严重影响性能，所以要权衡好这个值的设置，总体上还是最根本的时间成本和空间成本上的权衡。\n\n同样类似的参数还有：\n\nlist-max-ziplist-entries 512\n说明：list数据类型多少节点以下会采用去指针的紧凑存储格式。\n\nlist-max-ziplist-value 64 \n说明：list数据类型节点值大小小于多少字节会采用紧凑存储格式。\n\nset-max-intset-entries 512 \n说明：set数据类型内部数据如果全部是数值型，且包含多少节点以下会采用紧凑格式存储。\n\n最后想说的是Redis内部实现没有对内存分配方面做过多的优化，在一定程度上会存在内存碎片，不过大多数情况下这个不会成为Redis的性能瓶颈，不过如果在Redis内部存储的大部分数据是数值型的话，Redis内部采用了一个shared integer的方式来省去分配内存的开销，即在系统启动时先分配一个从1~n 那么多个数值对象放在一个池子中，如果存储的数据恰好是这个数值范围内的数据，则直接从池子里取出该对象，并且通过引用计数的方式来共享，这样在系统存储了大量数值下，也能一定程度上节省内存并且提高性能，这个参数值n的设置需要修改源代码中的一行宏定义REDIS_SHARED_INTEGERS，该值默认是10000，可以根据自己的需要进行修改，修改后重新编译就可以了。\n\n### Redis的持久化机制\n\nRedis由于支持非常丰富的内存数据结构类型，如何把这些复杂的内存组织方式持久化到磁盘上是一个难题，所以Redis的持久化方式与传统数据库的方式有比较多的差别，Redis一共支持四种持久化方式，分别是：\n\n- 定时快照方式(snapshot)\n- 基于语句追加文件的方式(aof)\n- 虚拟内存(vm)\n- Diskstore方式\n\n在设计思路上，前两种是基于全部数据都在内存中，即小数据量下提供磁盘落地功能，而后两种方式则是作者在尝试存储数据超过物理内存时，即大数据量的数据存储，截止到本文，后两种持久化方式仍然是在实验阶段，并且vm方式基本已经被作者放弃，所以实际能在生产环境用的只有前两种，换句话说Redis目前还只能作为小数据量存储（全部数据能够加载在内存中），海量数据存储方面并不是Redis所擅长的领域。下面分别介绍下这几种持久化方式：\n\n#### 定时快照方式(snapshot)：\n\n该持久化方式实际是在Redis内部一个定时器事件，每隔固定时间去检查当前数据发生的改变次数与时间是否满足配置的持久化触发的条件，如果满足则通过操作系统fork调用来创建出一个子进程，这个子进程默认会与父进程共享相同的地址空间，这时就可以通过子进程来遍历整个内存来进行存储操作，而主进程则仍然可以提供服务，当有写入时由操作系统按照内存页(page)为单位来进行copy-on-write保证父子进程之间不会互相影响。\n\n该持久化的主要缺点是定时快照只是代表一段时间内的内存映像，所以系统重启会丢失上次快照与重启之间所有的数据。\n\n#### 基于语句追加方式(aof)：\n\naof方式实际类似mysql的基于语句的binlog方式，即每条会使Redis内存数据发生改变的命令都会追加到一个log文件中，也就是说这个log文件就是Redis的持久化数据。\n\naof的方式的主要缺点是追加log文件可能导致体积过大，当系统重启恢复数据时如果是aof的方式则加载数据会非常慢，几十G的数据可能需要几小时才能加载完，当然这个耗时并不是因为磁盘文件读取速度慢，而是由于读取的所有命令都要在内存中执行一遍。另外由于每条命令都要写log,所以使用aof的方式，Redis的读写性能也会有所下降。\n\n#### 虚拟内存方式：\n\n虚拟内存方式是Redis来进行用户空间的数据换入换出的一个策略，此种方式在实现的效果上比较差，主要问题是代码复杂，重启慢，复制慢等等，目前已经被作者放弃。\n\n#### diskstore方式：\n\ndiskstore方式是作者放弃了虚拟内存方式后选择的一种新的实现方式，也就是传统的B-tree的方式，目前仍在实验阶段，后续是否可用我们可以拭目以待。\n\n### Redis持久化磁盘IO方式及其带来的问题\n\n有Redis线上运维经验的人会发现Redis在物理内存使用比较多，但还没有超过实际物理内存总容量时就会发生不稳定甚至崩溃的问题，有人认为是基于快照方式持久化的fork系统调用造成内存占用加倍而导致的，这种观点是不准确的，因为fork 调用的copy-on-write机制是基于操作系统页这个单位的，也就是只有有写入的脏页会被复制，但是一般你的系统不会在短时间内所有的页都发生了写入而导致复制，那么是什么原因导致Redis崩溃的呢？\n\n答案是Redis的持久化使用了Buffer IO造成的，所谓Buffer IO是指Redis对持久化文件的写入和读取操作都会使用物理内存的Page Cache,而大多数数据库系统会使用Direct IO来绕过这层Page Cache并自行维护一个数据的Cache，而当Redis的持久化文件过大(尤其是快照文件)，并对其进行读写时，磁盘文件中的数据都会被加载到物理内存中作为操作系统对该文件的一层Cache,而这层Cache的数据与Redis内存中管理的数据实际是重复存储的，虽然内核在物理内存紧张时会做Page Cache的剔除工作，但内核很可能认为某块Page Cache更重要，而让你的进程开始Swap ,这时你的系统就会开始出现不稳定或者崩溃了。我们的经验是当你的Redis物理内存使用超过内存总容量的3/5时就会开始比较危险了。\n\n下图是Redis在读取或者写入快照文件dump.rdb后的内存数据图：\n![](/upload_path/20151024/14456984073.jpg)\n\n### 总结：\n\n1. 根据业务需要选择合适的数据类型，并为不同的应用场景设置相应的紧凑存储参数。\n2. 当业务场景不需要数据持久化时，关闭所有的持久化方式可以获得最佳的性能以及最大的内存使用量。\n3. 如果需要使用持久化，根据是否可以容忍重启丢失部分数据在快照方式与语句追加方式之间选择其一，不要使用虚拟内存以及diskstore方式。\n4. 不要让你的Redis所在机器物理内存使用超过实际内存总量的3/5。', '本文将对Redis的常见数据类型的使用场景以及在内存优化方面和性能优化方面做一些详细的分析。', '/upload_path/20151024/14456981905.jpg', 33, 'Redis', 0, 1, '1445495831', '1445923336', 0, 0),
(10, '新年抒怀 /季羡林', 7, 6, '　　除夕之夜，半夜醒来，一看表，是一点半钟，心里轻轻地一颤：又过去一年了。\n　　   \n　　小的时候，总希望时光快快流逝，盼过节，盼过年，盼迅速长大成人。然而，时光却偏偏好像停滞不前，小小的心灵里溢满了忿忿不平之气。\n　　\n　　但是，一过中年，人生之车好像是从高坡上滑下，时光流逝得像电光一般。它不饶人，不了解人的心情，愣是狂奔不已。一转眼间，“两岸猿声啼不住，轻舟已过万重山”，滑过了花甲，滑过了古稀，少数幸运者或者什么者，滑到了耄耋之年。人到了这个境界，对时光的流逝更加敏感。年轻的时候考虑问题是以年计，以月计。到了此时，是以日计，以小时计了。\n　　\n　　我是一个幸运者或者什么者，眼前正处在耄耋之年。我的心情不同于青年，也不同于中年，纷纭万端，决不是三两句就能说清楚的。我自己也理不出一个头绪来。\n　　\n　　过去的一年，可以说是我一生最辉煌的年份之一。求全之毁根本没有，不虞之誉却多得不得了，压到我身上，使我无法消化，使我感到沉重。有一些称号，初戴到头上时，自己都感到吃惊，感到很不习惯。就在除夕的前一天，也就是前天，在解放后第一次全国性国家图书奖会议上，在改革开放以来十几年的，包括文理法农工医以及军事等等方面的五十一万多种图书中，在###和财政部的关怀和新闻出版署的直接领导下，经过全国七十多位专家的认真细致的评审，共评出国家图书奖四十五种。只要看一看这个比例数字，就能够了解获奖之困难。我自始至终参加了评选工作。至于自己同获奖有份，一开始时，我连做梦都没有梦到。然而结果我却有两部书获奖。在小组会上，我曾要求撤出我那一本书，评委不同意。我只能以不投自己的票的办法来处理此事。对这个结果，要说自己不高兴，那是矫情，那是虚伪，为我所不取。我更多地感觉到的是惶恐不安，感觉到惭愧。许多非常有价值的图书，由于种种原因，没有评上，自己却一再滥竽。这也算是一种机遇，也是一种幸运吧。我在这里还要补上一句：在旧年的最后一天的《光明日报》上，我读到老友邓广铭教授对我的评价，我也是既感且愧。\n　　\n　　我过去曾多次说到，自己向无大志，我的志是一步步提高的，有如水涨船高。自己决非什么天才，我自己评估是一个中人之才。如果自己身上还有什么可取之处的话，那就是，自己是勤奋的，这一点差堪自慰。我是一个富于感情的人，是一个自知文明超过需要的人，是一个思维不懒惰，脑筋永远不停地转动的人。我得利之处，恐怕也在这里。过去一年中，在我走的道路上，撒满了玫瑰花；到处是笑脸，到处是赞誉。我成为一个“很可接触者”。要了解我过去一年的心情，必须把我的处境同我的性格，同我内心的感情联系在一起。\n　　\n　　现在写“新年抒怀”，我的“怀”，也就是我的心情，在过去一年我的心情是什么样子的呢？\n　　\n　　首先是，我并没有被鲜花和赞誉冲昏了头脑，我的头脑是颇为清醒的。一位年轻的朋友说我似乎忘记了自己的年龄。这只是一个表面现象。尽管从表面上来看，我似乎是朝气蓬勃，在学术上野心勃勃，我揽的工作远远超过一个耄耋老人所能承担的，我每天的工作量在同辈人中恐怕也居上乘。但是我没有忘乎所以，我并没有忘记自己的年龄。在朋友欢笑之中，在家庭聚乐之中，在灯红酒绿之时，在奖誉纷至潮来之时，我满面含笑，心旷神怡，却蓦地会在心灵中一闪念：“这一出戏快结束了！”我像撞客的人一样，这一闪念紧紧跟随着我，我摆脱不掉。\n　　\n　　是我怕死吗？不，不，决不是的。我曾多次讲过：我的性命本应该在十年浩劫中结束的。在比一根头发丝还细的偶然性中，我侥幸活了下来。从那以后，我所有的寿命都是白拣来的；多活一天，也算是“赚了”。而且对于死，我近来也已形成了一套完整的看法：“应尽便须尽，无复独多虑。”死是自然规律，谁也违抗不得。用不着自己操心，操心也无用。\n　　\n　　那么我那种快煞戏的想法是怎样来的呢？记得在大学读书时，读过俞平伯先生的一篇散文：《重过西园码头》，时隔六十余年，至今记忆犹新。其中有一句话：“从现在起我们要仔仔细细地过日子了。”这就说明，过去日子过得不仔细，甚至太马虎。俞平伯先生这样，别的人也是这样，我当然也不例外。日子当前，总过得马虎。时间一过，回忆又复甜蜜。宋词中有一句话：“当时只道是寻常。”真是千古名句，道出了人们的这种心情。我希望，现在能够把当前的日子过得仔细一点，认为不寻常一点。特别是在走上了人生最后一段路程时，更应该这样。因此，我的快煞戏的感觉，完全是积极的，没有消极的东西，更与怕死没有牵连。\n　　\n　　在这样的心情的指导下，我想得很多很多，我想到了很多的人。首先是想到了老朋友。清华时代的老朋友胡乔木，最近几年曾几次对我说，他想要看一看年轻时候的老朋友。他说：“见一面少一面了！”初听时，我还觉得他过于感伤。后来逐渐品味出他这一句话的分量。可惜他前年就离开了我们，走了。去年我用实际行动响应了他的话，我邀请了六七位有五六十年友谊的老友聚了一次。大家都白发苍苍了，但都兴会淋漓。我认为自己干了一件好事。我哪里会想到，参加聚会的吴组缃现已病卧医院中。我听了心中一阵颤动。今年元旦，我潜心默祷，祝他早日康复，参加我今年准备的聚会。没有参加会的老友还有几位。我都一一想到了，我在这里也为他们的健康长寿祷祝。\n　　\n　　我想到的不只有老年朋友，年轻的朋友，包括我的第一代、第二代、第三代的学生，无论是在国内，还是在国外，我也都一一想到了。我最近颇接触了一些青年学生，我认为他们是我的小友。不知道为什么我对这一群小友的感情越来越深，几乎可以同我的年龄成正比。他们朝气蓬勃，前程似锦。我发现他们是动脑筋的一代，他们思考着许许多多的问题。淳朴，直爽，处处感动着我。俗话说：“长江后浪推前浪，世上新人换旧人。”我们祖国的希望和前途就寄托在他们身上，全人类的希望和前途也寄托在他们身上。对待这一批青年，惟一正确的做法是理解和爱护，诱导与教育，同时还要向他们学习。这是就公而言。在私的方面，我同这些生龙活虎般的青年们在一起，他们身上那一股朝气，充盈洋溢，仿佛能冲刷掉我身上这一股暮气，我顿时觉得自己年轻了若干年。同青年们接触真能延长我的寿命。古诗说：“服食求神仙，多为药所误。”我一不服食，二不求神。青年学生就是我的药石，就是我的神仙。我企图延长寿命，并不是为了想多吃人间几千顿饭。我现在吃的饭并不特别好吃，多吃若干顿饭是毫无意义的。我现在计划要做的学术工作还很多，好像一个人在日落西山的时分，前面还有颇长的路要走。我现在只希望多活上几年，再多走几程路，在学术上再多做点工作，如此而已。', 'ms', '', 13, '', 0, 1, '1446019649', '1446087359', 0, 1),
(11, '传播正能量——做一个快乐的程序员', 7, 6, '### 我们的累\n[我们搞开发的为什么会感觉到累](http://www.cnblogs.com/wenyang-rio/p/4261987.html "我们搞开发的为什么会感觉到累")，文中已经说了很多，简单的讲，主要是担心和紧张感以及加班的劳累。\n\n明天项目上线，通宵改BUG，好累。\n\n需求变来变去，这个项目什么时候是个头，好累\n\n现有的技术将要过时，面临淘汰，一堆的新技术要学，好累\n\n每天上下班总计四个小时，好累\n\n每天六点就要起床去上班，好累\n\n又要坐挤死人的地铁，好累\n\n。。。\n\n\n### 为什么会累\n本来的一个好觉，变成了通宵加班，打乱了作息规律，扰乱了生物钟，在本该休息的时候，还要面对巨大的思想压力去改BUG，顿感身心疲惫。\n\n需求变来变去，自己的辛勤工作，没有得到肯定，没有发光发热，可能一不小心就变成了无用功，在这种前提下，还要在可能因为工期紧张，面临加班的情况下，再做一次无用功，想想都感觉这样的日子好累啊，日月无光。\n\n辛辛苦苦，勤勤恳恳，没日没夜的学了些许知识、技术，总算是找个工作，有口饭吃。可是没用几天，这些技术就要面临淘汰，于是乎，又要辛辛苦苦，勤勤恳恳，没日没夜的学习新的技术，真想说句坑爹啊，还能不能和小朋友们愉快的玩耍，还能不能吃着火锅唱着歌。\n\n一天24个小时，工作8个小时，睡觉8个小时，吃饭2个小时，还剩6个小时的时间，但是就是这仅剩的时间还要有三分之二要花在上下班的路上，那么问题来了，还有没有打游戏的时间，还有没有学习新知识的时间，还有没有和朋友们吹牛B的时间，还有没有和妹子约会的时间。一天两天可以，可是每天如此，这样单调的生活，有何意义可言。\n\n每天六点起床上班，天还没亮，寒风刺骨，拖着饥饿的身体，费尽九牛二虎之力，终于挤进了充满各种气味的地铁里，却发现，在拥挤的人群中，自己学会了金鸡独立，乾坤大挪移，梦回张无忌。几声滴滴声将你拉回了现实，你终于发现，人世间最远的距离，不是生与死的距离，而是地铁到站，你刚下车，却被强大的人流挤上了车，这样的生活好累啊。\n\n。。。\n\n\n### 别人累吗\n我们这么累，我们这么惨，只有我们这样吗。我们还是睁大双眼，看看其他人吧。\n\n农民，起早贪黑，风吹日晒，累不累？\n\n销售，很多时候要与烟酒相伴，累不累？\n\n厨师，每天生活在油烟之中，累不累？\n\n管理，每天要纠结项目进度、项目期限，累不累？\n\n领导，中层领导有来自高层的压力，高层来自boss的压力，boss来自生存的压力和股东投资者的压力等，累不累？\n\n还有很多，不在这里一一列举。\n\n人这一辈子，可能也就小时候开心点。小学，各种作业；初中，面临升学的压力；高中，面临大学的压力；大学，面临找工作的压力；毕业后面临结婚的压力；结婚后又该要孩子了。有了孩子后，才知道从此忙忙碌碌几十年，等到孩子长大了，自己也就老了，可是老了，还要面临各种病痛。。。这么想来，人这一辈子，到底累不了？\n\n\n### 别人累吗——换个思路\n农民，起早贪黑，风吹日晒，辛辛苦苦，换来庄稼的丰收，有付出才会有收获，累吗？值得！\n\n销售，很多时候要与烟酒相伴，各种推销、与烟酒相伴、跑来跑去，换来一个一个合同，有付出才会有收获，累吗？值得！\n\n厨师，每天生活在油烟之中，锅碗瓢盆，斧钺钩叉，十八般武艺换来色香味俱全的美餐，有付出才会有收获，累吗？值得！\n\n管理，每天要纠结项目进度、项目期限，精打细算，换来项目的正常上线，产品的如期发布，有付出才会有收获，累吗？值得！\n\n领导，中层领导有来自高层的压力，高层来自boss的压力，boss来自生存的压力和股东投资者的压力等，有压力就有动力，有动力就能出成绩，有付出才会有收获，累吗？值得！\n\n人这一辈子，生老病死，各种压力，有了压力，才会体会到战胜压力的喜悦，有过辛酸，才能体会到生活的美好，努力付出，就一定会有收获，即使累，也值得！\n\n\n### 如何不累——保持好心态\n说了这么多，并不是想说明职业之前的差别，也不是想体现某些人的优越，只是想说明，心态不同，那么你眼中的世界必将大不相同。\n\n![](/upload_path/20151029/8dae2a580b350ec48a1b0a07a99b2267.png)\n\n遇到问题，尽全力解决即可，能解决，则体现了自己的能力，不能解决，也不能以死谢罪，饭还是要吃，觉还是要睡，生活还在继续，何苦闷闷不乐，折磨自己。保持好心情，迎接下一次挑战。\n\n![](/upload_path/20151029/a719c92ad0af815260a7aa7152cbad81.png)\n\n写这么多，举再多例子，不如牢记一句话，无论如何，保持好心情，对自己好一点！\n\n\n### 累的症结——运动量少\n人归根结底还是动物，所以每天要有适当的运动。为什么说适当呢，农民、工人、运动员等，由于过多的工作量、运动量，导致身体负荷过大，出现很多伤病。而我们程序员，由于久坐、少动，导致身体各机能降低，免疫力减弱，容易出现劳累，甚至伤病。\n\n程序员，这个职业导致普遍的少运动，所以身体出现问题的时候，总是怪罪于这个职业，其实，这是对自己的不负责任。纵使有万般理由，都是自己懒惰的借口，所谓的没时间，只是不想有时间而已。\n\n打游戏，看电影，可不可以抽出十分钟来活动活动筋骨，做做俯卧撑、仰卧起坐。\n\n其实只要你想，我们随时随地都有时间做锻炼。离公司近的，跑步上下班，离公司远的，把挤地铁当做一种锻炼；上下楼改为楼梯；刷微博、刷朋友圈的同时，蹲个马步；关上房门，只剩自己的时候，来一套想怎么打就怎么打、想怎么疯就怎么疯、比醉拳还醉的原生态拳。。。其余的大家可以发挥自己的想想。\n\n同为程序员，看看别人是如何做的：\n\n[布里斯班Twilight Bay Run半程马拉松](http://www.cnblogs.com/huang0925/p/3984364.html "布里斯班Twilight Bay Run半程马拉松")\n\n[程序员健身6个月总结](http://www.cnblogs.com/huang0925/p/4069921.html "程序员健身6个月总结")\n\n马拉松都出来了，难道围着软件园跑一圈就很难吗？\n\n关于养生，也可以读一下 [程序员秋季养生之道，今天你撸了吗？](http://www.cnblogs.com/wenyang-rio/p/3976375.html "程序员秋季养生之道，今天你撸了吗？")\n\n\n### 以己度人——将心比心\n刚工作的时候，接手了一个曾经外包的Portal，代码那叫一个乱，各种没注释，没文档，BUG还一大堆，维护这份代码，那简直是生活在水深火热之中，甚至有的时候想把作者的祖宗十八代问候一遍。\n\n后来，负责了一个新的项目，整理完需求后，开始调研、概要设计、详细设计、编码、测试，怎叫一个爽字了得，简直是动感地带，我的地盘我做主，没文档，少注释，各种特性，各种风格满天飞。\n\n后来接手数据库的一个模块，根据详细设计文档，很快便对这个模块有了整理的了解，甚至连为什么选用某框架，曾经遇到的问题，现在存在的问题，改进思路等都写得非常详细，代码中有很多注释，整体上来说，感觉非常舒服。\n\n这时候，再回过头来看自己负责的项目，与之前的Portal又有什么差别呢。等到哪一天，换了别人维护这份代码，由于我的原因，让他或他们生活在水深火热之中，于心不忍。于情于理，也说不过去。\n\n以己度人，将心比心，注释、文档、代码风格统一，整体可读性好，可维护性好，换来后来人的舒服，自己是不是也会感到很欣慰呢。\n\n\n### 停止疯狂的学习——总结也是一种进步\n前两年，刚工作不久，业余时间很多，也没有太多的事情分散精力，就一门心思的把时间用在学习上。基本上每天都要看看博客园等技术网站，吸取最新的技术知识。然后就是看书，进行系统的学习。\n\n由于自己的求知欲太强，总想学习新知识，基本上，看完一本书，就看下一本，一年下来，看了就几十本书吧。从编程语言到编译原理，从系统编程到系统内核，从面向对象到函数式编程，从机器间通信到多线程并发，从Web前端到大数据处理。所有这些基本上是工作上用到的知识，或者自己感兴趣的知识，或者属于未来的发展趋势。虽然自己涉猎颇多，但无奈还没有达到过目不忘的程度，貌似什么都懂，实际什么都不懂。到现在，曾经看过的书，已经忘了至少90%的内容，还有一部分，可能只知道个概念。好在我还有时间，通过这么多的涉猎，基本上确定了自己的发展方向，这也算唯一值得肯定的地方吧。\n\n我的这种做法，也算是一种典型吧，方法不当，学的再多，可能都变成了无用功。对于一般人来说，只看书，不实践，只能达到了解的程度，只有不断实践、总结、消化、吸收，才能真正掌握这些知识。\n\n保持一个好的心态，切记心浮气躁、急功近利，停止疯狂的学习，总结也是一种进步。\n\n\n### 好习惯受益终生\n夏天的时候，绿油油的草坪却经常出现光秃的一角。观察了几次，发现很多路人，行走到草坪一角的拐弯处时，没有进行直角转弯，而是从草坪的这一角，直穿而过，慢慢的这一角就变得光秃了。终于明白了鲁大师（鲁迅）的那句话：世上本无路，走的人多了，便成了路。\n\n看似不起眼的一件事情，有可能影响一个人的一生。\n\n穿过草坪，看似走了捷径，走了第一次，就还会有第二次，慢慢的养成了习惯，潜移默化中，可能会影响自己的性格，可能会变成一个爱走捷径的人，所以习惯很重要。\n\n那么从现在开始，培养好的习惯吧。每天坚持锻炼，强身健体，每天总结自己的收获，每天总结自己学到的知识，写写笔记，发表博客，想必用不了多长时间，不是专家，也必将是大牛。\n\n好习惯受益终生。\n\n\n### 珍惜眼前——享受生活\n我们总是会回想过去，回想过去的天真烂漫，回想过去的无拘无束，回想过去的轻松自在，尤其当遇到困难，或者出现伤病，止不住的感叹过去的美好。越是这样，就越要珍惜眼前，过好眼前的生活。让未来的自己回想过去，有更多美好的回忆。\n\n人生不是打游戏，没有存档，不能重来。无论贫贱富贵，无论生老病死，所有的一切都是生活的一部分。包括无休止的加班，包括没完没了的BUG。改完BUG，仰望一下深邃的夜空，加完班，欣赏一下美丽的日出，又何尝不可。\n\n无论如何，生活都会继续，珍惜眼前，享受生活，活出真正的自我。\n\n\n### 坚持就是胜利\n有一种勇气叫做忍耐，有一种力量叫做坚持。\n\n当夜幕掩盖了大地，明月还没升起，深山之中，踽踽独行，狼嚎猿啼。\n\n只是一个行路人，前方是万仞高峰，不是一座，蜿蜒起伏。他要做的，是到达山的那一方。\n\n没有捷径，只得一步步走下去。累了，靠着青石小憩；饿了，吃一口发硬的干粮；想家了，便加快脚步。\n\n人，有目标的活着，便能化疲惫为动力，牢骚为奇迹。\n\n而唯一能够做的，是坚持。\n\n因为山的那一方，叫做成功。\n\n贵有恒，何必三更起五更睡；最无益，只怕一日曝十日寒。\n\n很多事情，一次两次，非常简单，但长时间的坚持，却是非常难的。\n\n我们搞开发的为什么会感觉到累，可能就是因为没有锻炼身体，或者没有坚持锻炼身体。\n\n坚持做一件事情，一个月、两个月，一年、两年，可能不算很难，那么坚持一辈子呢，有几个人能做到呢。\n\n正是由于坚持很难，所以当我们真正开始坚持做一件事情的时候，必定会有收获，坚持的时间越长，收获越多。\n\n坚持就是胜利！\n\n\n### 说到容易做到难——修身养性\n道理大家都懂，但说到容易做到难。\n\n人都有七情六欲，不可能永远都有一个好心情、好心态。只要努力去做，并尽量保持一个好的心态，就已经非常不错了。\n\n夜深人静，睡觉之前，闭目养神，让自己的心重归于宁静，思考得失，思考人生。不断修身养性，必定更容易保持好的心态。\n\n\n### 总结\n文笔太差，废话一堆，写了这么多，只想表达一个意思：希望大家坚持锻炼身体，保持一个好的心态，乐观面对生活，笑对人生。\n\n', '今天在博客园看到施瓦小辛格的文章我们搞开发的为什么会感觉到累，顿时有感而发。自己本来不擅长写文章，更不擅长写这种非技术性的文章，但是在思绪喷薄之际，还是止不住有很多话要说。针对从客观上说”搞开发的很累”这种说法，我也来发表一下我的看法。——缘生梦（作者），转自博客园', '/upload_path/20151029/8dae2a580b350ec48a1b0a07a99b2267.png', 20, '健康', 1, 1, '1446108335', '1446108434', 1, 1),
(12, '设计师喝多后设计的房子，真是醉了', 7, 10, '1.颠倒屋|波兰\n\n![](/upload_path/20151030/5b93817934871918f38ce2db289d8796.jpg)\n\n里面还有经典的装饰，当然也是倒挂着的。现在它对外开放，游客可以进去并且踩在天花板（地板）上？\n\n2.疯房子|越南\n\n![](/upload_path/20151030/93403042a20e5642e5a047d6b0f80d06.jpg)\n\n它里面包含了很多自然生物：有动物、蘑菇、一个很大的树干。建成超出预算极多……\n\n3.卫生间的房子|韩国\n\n![](/upload_path/20151030/6db8f193e8c5bdb616c4d4ca95dc6711.jpg)\n\n它由世界厕所协会创办人建造，这个公益组织曾为改善世界各地卫生设备做出了很多贡献。在建造者去世之前，这儿一直是他的私人会所，现在已经成为一个厕所博物馆。\n\n4.鞋房子|南非\n\n![](/upload_path/20151030/3d37e9263b3c8ef91bb718f14ce70c0d.jpg)\n\n当地艺术家在1990年决定做一个这样的房子给他的妻子。\n\n5.生物气候太阳能住宅|法（四声）国\n\n![](/upload_path/20151030/b2dbf9c793a4ed12ab4f7b46198a30c9.jpg)\n\n这个房子将“环境友好型”提升到了一个新的高度\n\n6.鳄鱼的房子|象牙海岸\n\n![](/upload_path/20151030/0cd00cd82d05e3694db1a0eeb2a75d65.jpg)\n\n这个房子现在是有人住的！\n\n7.波音727房|哥斯达黎加\n\n![](/upload_path/20151030/5065a01d1101d4a1924d391eb770cf31.jpg)\n\n里面有两室两浴室，据说装修的还不错哦。\n\n8.钟楼顶层屋|纽约.布鲁克林\n\n![](/upload_path/20151030/7477b170767911f99159a86180e9d5ea.jpg)\n\n时钟每半个小时响一次，问：主人能睡得好吗？\n\n9.旋转屋|澳大利亚\n\n![](/upload_path/20151030/c106f0eb5aae4b8bb9aedbcda39c2a76.jpg)\n\n如题，它一直在旋转着……不会晕吗\n\n10.窄楼|东京\n\n![](/upload_path/20151030/e4e6a51718aa65e9a8e9b01166ed760a.jpg)\n\n遇上大风真的不会被掀翻？\n\n11.飞行器房|田纳西\n\n![](/upload_path/20151030/eb8ed4e886a998aa3cff1e6257598836.jpg)\n\n伙计们准备好了吗？1、2、3、起飞！\n\n12.小房子|华盛顿\n\n![](/upload_path/20151030/41f5f30d29ae143b018f40daaff9d370.jpg)\n\n这个房子只有13平方米！（如果电脑换算器的数据准确的话……）里面包含着厨房卫生间阁楼卧室和书房……\n\n13.透明的房子|日本\n\n![](/upload_path/20151030/12be5bbd55bf27937e52f2c3fa296500.jpg)\n\n每到沐浴时间，屋外就会聚集起莫名的人流…\n\n14.会动的房子\n\n![](/upload_path/20151030/0719b8067e97b821aca0177409f10c73.jpg)\n\n19.2㎡，有卧室有书房有厨房，最重要的是它可以移动！\n\n原文地址：[设计师喝多后设计的房子，真是醉了](http://www.yyyweb.com/3462.html "设计师喝多后设计的房子，真是醉了")', '转自：前端里 » 设计师喝多后设计的房子，真是醉了，作者小鱼', '/upload_path/20151030/5b93817934871918f38ce2db289d8796.jpg', 6, '', 0, 1, '1446170790', '1446170851', 1, 0),
(13, '瓦尔特', 7, 10, '那么我那种快煞戏的想法是怎样来的呢？记得在大学读书时，读过俞平伯先生的一篇散文：《重过西园码头》，时隔六十余年，至今记忆犹新。其中有一句话：“从现在起我们要仔仔细细地过日子了。”这就说明，过去日子过得不仔细，甚至太马虎。俞平伯先生这样，别的人也是这样，我当然也不例外。日子当前，总过得马虎。时间一过，回忆又复甜蜜。宋词中有一句话：“当时只道是寻常。”真是千古名句，道出了人们的这种心情。我希望，现在能够把当前的日子过得仔细一点，认为不寻常一点。特别是在走上了人生最后一段路程时，更应该这样。因此，我的快煞戏的感觉，完全是积极的，没有消极的东西，更与怕死没有牵连。\n　　\n　　在这样的心情的指导下，我想得很多很多，我想到了很多的人。首先是想到了老朋友。清华时代的老朋友胡乔木，最近几年曾几次对我说，他想要看一看年轻时候的老朋友。他说：“见一面少一面了！”初听时，我还觉得他过于感伤。后来逐渐品味出他这一句话的分量。可惜他前年就离开了我们，走了。去年我用实际行动响应了他的话，我邀请了六七位有五六十年友谊的老友聚了一次。大家都白发苍苍了，但都兴会淋漓。我认为自己干了一件好事。我哪里会想到，参加聚会的吴组缃现已病卧医院中。我听了心中一阵颤动。今年元旦，我潜心默祷，祝他早日康复，参加我今年准备的聚会。没有参加会的老友还有几位。我都一一想到了，我在这里也为他们的健康长寿祷祝。\n　　![](/upload_path/20151030/0abc06d50ff26d60c4a24b07d1ad942f.jpg)\n　　我想到的不只有老年朋友，年轻的朋友，包括我的第一代、第二代、第三代的学生，无论是在国内，还是在国外，我也都一一想到了。我最近颇接触了一些青年学生，我认为他们是我的小友。不知道为什么我对这一群小友的感情越来越深，几乎可以同我的年龄成正比。他们朝气蓬勃\n  ![](/upload_path/20151030/51b7ccd798702d64eb3c8cea733739c5.jpg)\n  ，前程似锦。我发现他们是动脑筋的一代，他们思考着许许多多的问题。淳朴，直爽，处处感动着我。俗话说：“长江后浪推前浪，世上新人换旧人。”我们祖国的希望和前途就寄托在他们身上，全人类的希望和前途也寄托在他们身上。对待这一批青年，惟一正确的做法是理解和爱护，诱导与教育，同时还要向他们学习。这是就公而言。在私的方面，我同这些生龙活虎般的青年们在一起，他们身上那一股朝气，充盈洋溢，仿佛能冲刷掉我身上这一股暮气，我顿时觉得自己年轻了若干年。同青年们接触真能延长我的寿命。古诗说：“服食求神仙，多为药所误。”我一不服食，二不求神。青年学生就是我的药石，就是我的神仙。我企图延长寿命，并不是为了想多吃人间几千顿饭。我现在吃的饭并不特别好吃，多吃若干顿饭是毫无意义的。我现在计划要做的学术工作还很多，好像一个人在日落西山的时分，前面还有颇长的路要走。我现在只希望多活上几年，再多走几程路，在学术上再多做点工作，如此而已。\n  ![](/upload_path/20151030/a6ddf009fa77834b63b8a4801072a887.jpg)\n  ', '认为其他', '/upload_path/20151030/0abc06d50ff26d60c4a24b07d1ad942f.jpg', 8, '', 0, 0, '1446174020', '1446186829', 1, 1),
(14, '测试哦', 7, 6, '上网官方的公会', '235', NULL, 1, '', 0, 0, '1446187916', '1446187916', 0, 0);
INSERT INTO `article` (`id`, `title`, `uid`, `cid`, `content`, `description`, `logo_dir`, `view`, `tags`, `comment`, `is_publish`, `addtime`, `update_time`, `praise`, `store`) VALUES
(15, '看完此站，整个人都不好了！不仅仅因为碉堡的创意', 7, 10, '网站是由沈阳心理研究所建立，虽然这个机构听上去像是一个web1.0风格官网的事业单位。但是今天所推荐的这个站，牛逼的不是一点点！整个网站的主要内容由6个短视频组成，每个故事有着不同的关键词，但是都是围绕着”语音暴力”这个主题展开。\n\nWeb端网页：http://www.wordscanbeweapons.com/\n手机端网页：http://www.sipcn.com/wordscanbeweapons/\n\n2014年4月29日，北京－由青少年暴力所导致的悲剧行为在中国正呈上升趋势。近年来，尽管青少年的人口总数在下降，被法庭判刑的未成年罪犯的数目却增加超过一倍。 一个鲜为人知的研究表明，在中国，青少年犯罪与童年时期遭受语言暴力之间有强烈的联系。沈阳市心理研究所联手北京奥美，通过创意传播活动提升中国公众对语言暴力的严重性和危害性的认知。\n\n奥美与来自沈阳的知名艺术家兼教授谢勇合作，将诸如此类的伤害性词语通过镀镍钢制作成模具。这些词语模具可以拆解并拼凑成致命武器的形状，比如枪、刀和斧头——如同这些青少年犯罪时所使用的武器。这个作品展示了暴力性语言如何真实地转化为武器。\n\n奥美的团队还为这个特别的问题建立了一个迷你网站。浏览者能够在线体验这些词语变成武器的过程，观看每位青少年讲述自己故事的影片，还能够在网上联系专业的辅导人员，探讨精神和语言暴力话题。这一系列传播活动产生了深远的影响。在网站上线后的前两周便接收了超过300个心理咨询热线电话。\n\n为了更广泛地传播这一话题，Social@Ogilvy团队通过微博接触社交媒体意见领袖，如青少年和育儿媒体的编辑，在第一个月里生成了约31万次的浏览量。更重要的是，团队还开通了官方微信账号”青少年心理咨询”，作为帮助中国青少年获取专业匿名咨询的平台。\n\n北京奥美广告执行创意总监赵琦( Juggi Ramakrishnan) 表示， “我们通过与研究所的心理学家交谈了解到，对儿童的语言暴力就如同引爆一颗定时炸弹，它只会在行凶者离开现场足够久之后才会爆炸。社会为此付出了代价，这一点从青少年犯罪率增加就可以看出来。我们真的需要通过这种能够唤醒人们的方式讲述这一”暴力循环”的故事。”\nVIA：mlxinmeili\n\n相关推荐：\n《网页设计新招式：火力全开！引爆网页中的视频应用》\n《超赞！30个创意十足的个人展示网站》\n\n本工花了半个小时来截图跟梳理视频内容，因为这个网站无论是设计跟内容都无法用语言去简单描述。所以，下面我们来看图解吧！\n\n沈阳市心理研究所：特殊展览\n故事一：猪脑子\n网站一点进去是巨大的”猪脑子”字样，文字效果很特别的样子。\n\n1\n\n鼠标下滑，文字开始变形！\n\n2\n\n继续变形，噢~现在开始有雏形了！好像是一把枪！\n\n3\n真的成了一把手枪！然后下方出现一个圆圆的按钮，hover上去会有一个视频的入口！讲的就是”猪脑子”的故事…\n\n4\n \n5\n视频开始了！\n\n故事是这样的：男主角的爸爸在男主角的小时候经常骂他”猪脑子、猪脑子…”因此男主角从小就很自卑，为了能让自己的爸爸看得起自己，男主开始赌博，结果被人下了套越赌越大越大输的越多，结果不光输了钱，还被赌场的人骂。男主内心的导火索终于被点燃了！然后，他弄了一把枪把赌场里的人杀了…\n\n6\n\n7\n\n故事二：怎么不去死\n\n鼠标向下滚动，看到巨大的五个字”你怎么不去死”，依旧是拼接出来的字体。\n\n8\n滚动鼠标两下之后，变成了一把匕首。\n\n9\n\n1011\n视频开始，故事内容：\n\n男主从小父母离异，男主跟着妈妈。而男主的妈妈经常把气撒在男主身上，叫他去死。男主初中辍学之后去了理发店当小工，一次不小心把客户烫到了，道歉之后店长依然很生气的叫他去死。男主最后将店长捅死…\n\n12\n13\n\n14\n\n故事三：废物\n\n看到这里，大家已经了解这个网站的效果套路了。都是标题的文字在滚动几次之后会组成一个凶器的样子。OK，我们继续来看第三个故事。\n\n15\n这次字体变成了一把弩，在此之前本工以为凶器的样式是随机的，看到这个故事的时候才发现，其实每个标题所变成的凶器，都是会在故事里出现的！这一点在设计上很牛逼有没有！！\n\n16\n\n17\n\n故事梗概：男主从小在农村长大。男主的爸爸酗酒严重，男主妈妈有病卧床不起。男主初中辍学出去打工，结果工厂的车间主任跟男主的爸爸一个脾气，总是说男主是：废物废物废物……男主忍无可忍，最后自己做了一把弩，射了主任一箭，导致主任瘫痪了……\n\n18\n19\n\n20\n\n故事四：就知道吃\n\n这句话肯定”中伤”了很多吃货……\n\n21\n这次变出来的凶器很奇特，本工不知道是什么=。=（我是好人，对凶器不大了解）貌似是个套在手上的东西！\n\n22\n\n23\n\n故事开始：男主还是个在校学生。妈妈比较溺爱，因为男主考试及格了就给男主买了一个手机。但男主妈妈溺爱的同时也恨铁不成钢，给男主报了很多补习班，并且偶尔会抱怨男主”成绩不佳就知道吃”（能吃也是错啊T T）！男主不爱学习，交了一个女朋友，但是女友劈腿了，好面子的男主就买了一个上图的凶器将女友劈腿的那个男同学捅成重伤…\n\n24\n25\n\n26\n\n故事五：丢人\n\n“丢人”！这个词相比上面的各种句式来说，出现频率应该是更高的。这次是变成了斧子！\n\n27\n28\n\n故事内容：男主成绩不好，一事无成。所以，男主的爸爸总是嫌弃男主丢人，并且总是在嘴边念叨。男主很小就辍学在家帮忙照看家中开的饭馆，结果对面饭馆的店长总是来这边抢客人，并且嘲笑男主丢人连这点事情都做不好。男主一怒之下砍伤了店长……在狱中，男主的爸爸也没有来看过男主，因为嫌他丢人！\n\n29\n故事六：是个人都比你强\n\n标题在滑动之后变成了枪的形状！\n\n30\n\n31\n\n故事内容：男主的爸爸是校长，对孩子要严格。男主有两个成绩好的哥哥，只有男主成绩不好，很贪玩。于是男主的爸爸总是很鄙视男主，说是个人都比他强。男主为了逃避这样的生活状态，每天上网打游戏，结果游戏中的团长也总是在游戏中鄙视男主，男主一怒之下买了一把仿真器，自行改造之后将团长枪杀了，男主在杀人之后丝毫没有悔意，反而觉得自己终于出息了一次，感觉”特别的爽”！！\n\n32\n33\n\n图解完这几个故事之后，本工整个人都不好了。语言所带来的暴力影响远比想象中的更加严重。很多时候，父母在教育孩子时并未意识到自己的言行会给孩子带来多大的影响。往往这些而是的语言，就是后来暴力之源。', '网站是由沈阳心理研究所建立，虽然这个机构听上去像是一个web1.0风格官网的事业单位。但是今天所推荐的这个站，牛逼的不是一点点！整个网站的主要内容由6个短视频组成，每个故事有着不同的关键词，但是都是围绕着”语音暴力”这个主题展开。', NULL, 2, '', 0, 0, '1446189780', '1446189780', 0, 0);

-- --------------------------------------------------------

--
-- 表的结构 `bug`
--

CREATE TABLE IF NOT EXISTS `bug` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `content` text CHARACTER SET utf8 NOT NULL,
  `uid` int(11) NOT NULL,
  `addtime` varchar(20) CHARACTER SET utf8 NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB  DEFAULT CHARSET=latin1 AUTO_INCREMENT=7 ;

--
-- 转存表中的数据 `bug`
--

INSERT INTO `bug` (`id`, `content`, `uid`, `addtime`) VALUES
(5, '问题', 7, '1445935610'),
(6, '12684', 7, '1445935668');

-- --------------------------------------------------------

--
-- 表的结构 `cloumn`
--

CREATE TABLE IF NOT EXISTS `cloumn` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(20) NOT NULL,
  `count` int(11) DEFAULT '0' COMMENT '文章数',
  `addtime` varchar(20) NOT NULL,
  `uid` int(11) NOT NULL,
  `description` text NOT NULL,
  `view` int(11) DEFAULT '0',
  `care` int(11) DEFAULT '0',
  `update_time` varchar(20) DEFAULT NULL,
  `logo_dir` text NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB  DEFAULT CHARSET=utf8 AUTO_INCREMENT=11 ;

--
-- 转存表中的数据 `cloumn`
--

INSERT INTO `cloumn` (`id`, `name`, `count`, `addtime`, `uid`, `description`, `view`, `care`, `update_time`, `logo_dir`) VALUES
(6, '文章', 3, '1444442275', 7, '一些无关技术有关engineer的文章(づ￣ 3￣)づ', 56, 0, '1446188765', '/upload_path/cloumn-logo/cloumn_logo_uid_7_20151028.jpg'),
(7, 'web圈api接口', 2, '1444623874', 5, '详细描述后台api接口的文档集合，方便以后开发使用', 11, 0, NULL, '/upload_path/cloumn-logo/352dd7e4fe628334d710278b51d5d38a.jpg'),
(8, 'php基础修炼', 3, '1445220312', 5, '主要包括php的基本函数、方法和一些基本的编程技巧', 29, 1, NULL, '/upload_path/cloumn-logo/3127f458b5bddcb5e5148bc9f149f48c.jpg'),
(9, 'redis', 1, '1445495506', 5, 'redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set --有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。', 6, 0, NULL, '/upload_path/cloumn-logo/43b9f3d4b35215265cbb85a92c320962.jpg'),
(10, '天马行空', 1, '1446088020', 7, '发挥你的想象与创意', 12, 0, NULL, '/upload_path/cloumn-logo/cloumn_logo_uid_7_20151029.jpg');

-- --------------------------------------------------------

--
-- 表的结构 `comment`
--

CREATE TABLE IF NOT EXISTS `comment` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `uid` int(11) NOT NULL,
  `aid` int(11) NOT NULL,
  `content` text NOT NULL,
  `addtime` varchar(20) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB  DEFAULT CHARSET=utf8 AUTO_INCREMENT=15 ;

--
-- 转存表中的数据 `comment`
--

INSERT INTO `comment` (`id`, `uid`, `aid`, `content`, `addtime`) VALUES
(9, 5, 2, '你就不能改改文章的格式？！！！！', '1444443334'),
(10, 7, 2, '@殷士凯 就不改', '1446001377'),
(11, 7, 2, '@殷士凯 不改又怎样\n哈哈', '1446086121'),
(12, 5, 2, '@暖晴 。。。。', '1446086296'),
(13, 10, 7, '赞赞', '1447069576'),
(14, 10, 11, '恩恩，写的很好', '1447069885');

-- --------------------------------------------------------

--
-- 表的结构 `news`
--

CREATE TABLE IF NOT EXISTS `news` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `send_id` int(11) NOT NULL,
  `receive_id` int(11) NOT NULL,
  `aid` int(11) NOT NULL,
  `unread` tinyint(1) NOT NULL DEFAULT '1',
  `addtime` varchar(20) CHARACTER SET utf8 NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB  DEFAULT CHARSET=latin1 AUTO_INCREMENT=6 ;

--
-- 转存表中的数据 `news`
--

INSERT INTO `news` (`id`, `send_id`, `receive_id`, `aid`, `unread`, `addtime`) VALUES
(1, 7, 7, 2, 0, '1446001377'),
(2, 7, 5, 2, 0, '1446086121'),
(3, 5, 7, 2, 0, '1446086296'),
(4, 10, 5, 7, 1, '1447069576'),
(5, 10, 7, 11, 1, '1447069885');

-- --------------------------------------------------------

--
-- 表的结构 `tag`
--

CREATE TABLE IF NOT EXISTS `tag` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(30) COLLATE utf8_unicode_ci NOT NULL,
  `description` text COLLATE utf8_unicode_ci NOT NULL,
  `addtime` varchar(20) COLLATE utf8_unicode_ci NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB  DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci AUTO_INCREMENT=5 ;

--
-- 转存表中的数据 `tag`
--

INSERT INTO `tag` (`id`, `name`, `description`, `addtime`) VALUES
(1, 'php', 'PHP，是英文超文本预处理语言 Hypertext Preprocessor 的缩写。PHP 是一种 HTML 内嵌式的语言，是一种在服务器端执行的嵌入 HTML 文档的脚本语言，语言的风格有类似于C语言，被广泛的运用。', '1443954531'),
(2, 'javascipt', 'JavaScript 是一门弱类型的动态脚本语言，支持多种编程范式，包括面向对象和函数式编程，被广泛用于 web 开发。', '1443955109'),
(3, 'Redis', 'Redis 是一个高性能的key-value数据库。 redis的出现，很大程度补偿了memcached这类key/value存储的不足，在部 分场合可以对关系数据库起到很好的补充作用。它提供了Java，C/C++，C#，PHP，JavaScript，Perl，Object-C，Python，Ruby，Erlang等客户端，使用很方便。', '1445495586'),
(4, '健康', '程序猿革命的本钱', '1446108364');

-- --------------------------------------------------------

--
-- 表的结构 `team`
--

CREATE TABLE IF NOT EXISTS `team` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `cid` int(11) NOT NULL,
  `uid` int(11) NOT NULL,
  `addtime` varchar(20) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 AUTO_INCREMENT=1 ;

-- --------------------------------------------------------

--
-- 表的结构 `user`
--

CREATE TABLE IF NOT EXISTS `user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `username` varchar(20) NOT NULL COMMENT '昵称',
  `realname` varchar(20) DEFAULT NULL COMMENT '真实姓名',
  `password` varchar(50) NOT NULL,
  `email` varchar(20) NOT NULL,
  `phone` varchar(20) DEFAULT NULL,
  `sex` tinyint(1) NOT NULL DEFAULT '0',
  `city` varchar(50) DEFAULT NULL COMMENT '所在城市',
  `job` varchar(50) NOT NULL COMMENT '职位',
  `company` varchar(50) DEFAULT NULL COMMENT '公司',
  `github` varchar(50) DEFAULT NULL,
  `description` text,
  `status` tinyint(1) NOT NULL DEFAULT '0' COMMENT '前后台身份',
  `token` varchar(20) DEFAULT NULL,
  `last_login_ip` varchar(20) DEFAULT NULL COMMENT '最后登陆的ip',
  `last_login_time` varchar(20) DEFAULT NULL COMMENT '最后登陆的时间',
  `addtime` varchar(20) NOT NULL,
  `logo_dir` varchar(50) DEFAULT NULL,
  `email_check` tinyint(1) NOT NULL DEFAULT '0',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB  DEFAULT CHARSET=utf8 AUTO_INCREMENT=11 ;

--
-- 转存表中的数据 `user`
--

INSERT INTO `user` (`id`, `username`, `realname`, `password`, `email`, `phone`, `sex`, `city`, `job`, `company`, `github`, `description`, `status`, `token`, `last_login_ip`, `last_login_time`, `addtime`, `logo_dir`, `email_check`) VALUES
(5, '殷士凯', NULL, '96e79218965eb72c92a549dd5a330112', '1181102772@qq.com', NULL, 0, '', 'UI设计师', NULL, NULL, '', 0, NULL, '175.25.169.70', '1446460932', '1438010485', '/upload_path/logo/web5.jpg', 0),
(7, '暖晴', '', '8144ddbeda4771dfe1bcc6ad7c1f51da', '1185534172@qq.com', NULL, 1, '', 'web前端', NULL, NULL, '我是老板娘~ ~  哈哈哈哈', 0, NULL, '58.132.166.23', '1447053325', '1444442206', '/upload_path/logo/web7.jpg', 0),
(8, '胡亚伟', NULL, '96e79218965eb72c92a549dd5a330112', '2409551912@qq.com', NULL, 0, NULL, '网站开发', NULL, NULL, NULL, 0, NULL, '101.75.132.232', '1444469072', '1444469070', NULL, 0),
(9, 'luckyYao', NULL, 'af037cb2290609c8cd4c6a374ff09079', '1061153071@qq.com', NULL, 0, NULL, 'web前端', NULL, NULL, NULL, 0, NULL, '111.227.161.174', '1445920762', '1445920760', NULL, 0),
(10, 'huyawei', '', '8ebd2b3e32abf6c769b9590fee14dcbe', '2409551912@qq.com', NULL, 0, '', 'web前端开发师', NULL, NULL, '', 0, NULL, '101.75.132.88', '1447069461', '1447069458', '', 0);

-- --------------------------------------------------------

--
-- 表的结构 `user_article`
--

CREATE TABLE IF NOT EXISTS `user_article` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `aid` int(11) NOT NULL,
  `author_id` int(11) NOT NULL,
  `uid` int(11) NOT NULL,
  `type` tinyint(1) NOT NULL DEFAULT '0',
  `addtime` char(20) COLLATE utf8mb4_unicode_ci NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB  DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci AUTO_INCREMENT=26 ;

--
-- 转存表中的数据 `user_article`
--

INSERT INTO `user_article` (`id`, `aid`, `author_id`, `uid`, `type`, `addtime`) VALUES
(12, 8, 5, 5, 1, '1446085228'),
(13, 10, 7, 5, 1, '1446085357'),
(14, 2, 0, 7, 1, '1446086102'),
(15, 6, 0, 7, 1, '1446086219'),
(17, 7, 0, 7, 0, '1446086230'),
(18, 12, 7, 5, 0, '1446173944'),
(19, 11, 7, 5, 0, '1446183587'),
(20, 13, 7, 7, 0, '1446186834'),
(21, 13, 7, 7, 1, '1446186863'),
(23, 7, 5, 5, 1, '1446460805'),
(24, 11, 7, 5, 1, '1446460822'),
(25, 2, 7, 5, 1, '1446460961');

-- --------------------------------------------------------

--
-- 表的结构 `user_care_cloumn`
--

CREATE TABLE IF NOT EXISTS `user_care_cloumn` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `uid` int(11) NOT NULL,
  `cid` int(11) NOT NULL,
  `addtime` varchar(20) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB  DEFAULT CHARSET=utf8 AUTO_INCREMENT=25 ;

--
-- 转存表中的数据 `user_care_cloumn`
--

INSERT INTO `user_care_cloumn` (`id`, `uid`, `cid`, `addtime`) VALUES
(23, 7, 8, '1446085953');

/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
